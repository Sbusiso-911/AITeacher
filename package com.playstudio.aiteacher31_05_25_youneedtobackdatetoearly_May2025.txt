package com.playstudio.aiteacher

import TooltipDialog
import WhisperHelper
import android.Manifest
import android.animation.ObjectAnimator
import android.app.Activity
import android.app.AlertDialog
import android.content.ActivityNotFoundException
import android.content.ClipData
import android.content.ClipboardManager
import android.content.ContentValues
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.content.res.ColorStateList
import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.graphics.Color
import android.graphics.ImageDecoder
import android.graphics.Typeface
import android.media.AudioFormat
import android.media.MediaCodec
import android.media.MediaExtractor
import android.media.MediaFormat
import android.media.MediaPlayer
import android.media.MediaRecorder
import android.net.ConnectivityManager
import android.net.Uri
import android.os.Build
import android.os.Bundle
import android.os.Environment
import android.provider.MediaStore
import android.speech.RecognitionListener
import android.speech.RecognizerIntent
import android.speech.SpeechRecognizer
import android.speech.tts.TextToSpeech
import android.support.annotation.RequiresApi
import android.text.Html
import android.text.Spannable
import android.text.SpannableString
import android.text.style.ClickableSpan
import android.text.style.ForegroundColorSpan
import android.text.style.UnderlineSpan
import android.util.Log
import android.view.*
import android.view.animation.AnimationUtils
import android.view.inputmethod.InputMethodManager
import android.webkit.WebView
import android.webkit.WebViewClient
import android.widget.*
import androidx.activity.result.ActivityResultLauncher
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AppCompatActivity
import androidx.appcompat.view.menu.MenuPopupHelper
import androidx.core.app.ActivityCompat
import androidx.core.content.ContentProviderCompat.requireContext
import androidx.core.content.ContextCompat
import androidx.core.content.ContextCompat.startActivity
import androidx.core.content.FileProvider
import androidx.fragment.app.Fragment
import androidx.fragment.app.activityViewModels
import androidx.lifecycle.Observer
import androidx.lifecycle.lifecycleScope
import androidx.recyclerview.widget.LinearLayoutManager
import com.airbnb.lottie.LottieAnimationView
import com.bumptech.glide.Glide
import com.canhub.cropper.CropImage
import com.canhub.cropper.CropImageView
import com.google.android.gms.ads.AdRequest
import com.google.android.gms.ads.LoadAdError
import com.google.android.gms.ads.interstitial.InterstitialAd
import com.google.android.gms.ads.rewarded.RewardItem
import com.google.android.gms.ads.rewarded.RewardedAd
import com.google.android.gms.ads.rewarded.RewardedAdLoadCallback
import com.google.mlkit.vision.common.InputImage
import com.google.mlkit.vision.text.Text
import com.google.mlkit.vision.text.TextRecognition
import com.google.mlkit.vision.text.latin.TextRecognizerOptions
import com.playstudio.aiteacher.databinding.FragmentChatBinding
import com.playstudio.aiteacher.utils.FileUtils
import com.tom_roush.pdfbox.android.PDFBoxResourceLoader
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import okhttp3.*
import okhttp3.MediaType.Companion.toMediaTypeOrNull
import okhttp3.RequestBody.Companion.toRequestBody
import org.json.JSONArray
import org.json.JSONException
import org.json.JSONObject
import java.io.ByteArrayOutputStream
import java.io.File
import java.io.FileOutputStream
import java.io.IOException
import java.io.InputStream
import java.text.SimpleDateFormat
import java.util.*
import java.util.concurrent.TimeUnit
import android.util.Base64


class ChatFragment : Fragment(), TextToSpeech.OnInitListener {
    // Add this data class inside your ChatFragment class
    data class Citation(
        val url: String,
        val title: String,
        val startIndex: Int,
        val endIndex: Int
    )

    private fun showCitationDialog(citation: Citation) {
        AlertDialog.Builder(requireContext())
            .setTitle("Source: ${citation.title}")
            .setMessage(citation.url)
            .setPositiveButton("Visit") { _, _ ->
                // Load URL in WebView
                binding.webView.visibility = View.VISIBLE
                binding.webView.loadUrl(citation.url)
            }
            .setNegativeButton("Copy") { _, _ ->
                val clipboard = requireContext().getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager
                val clip = ClipData.newPlainText("Source URL", citation.url)
                clipboard.setPrimaryClip(clip)
                showCustomToast("URL copied to clipboard")
            }
            .setNeutralButton("Close") { dialog, _ ->
                binding.webView.visibility = View.GONE
                dialog.dismiss()
            }
            .show()
    }
    // ... rest of your existing code ...

    private var mediaRecorder: MediaRecorder? = null
    private var speechRecognizer: SpeechRecognizer? = null
    private var isRecordingMeeting = false
    private var isRecording = false

    private var consecutiveApiKeyErrors = 0
    private val MAX_API_KEY_ERRORS_BEFORE_UPDATE = 3
    private var outputFile: String = ""
    private var meetingTranscript = StringBuilder()

    // Web search related constants
    private val WEB_SEARCH_MODELS = listOf(
        "gpt-4o-search-preview",
        "gpt-4o-mini-search-preview"
    )
    private var isWebSearchEnabled = false



    private lateinit var chatTextView: TextView
    private var interstitialAd: InterstitialAd? = null
    private var isInterstitialAdLoaded = false
    private val CHAT_COUNT_KEY = "chat_count"
    private val SUBSCRIPTION_PROMPT_THRESHOLD = 3
    private val PREFS_NAME = "app_prefs"
    private val FIRST_LAUNCH_KEY = "first_launch"
    private val GREETING_SENT_KEY = "greeting_sent"
    private val INTERACTION_COUNT_KEY = "interaction_count"
    private val RATING_REMINDER_COUNT_KEY = "rating_reminder_count"
    private var isLoading = false
    private var _binding: FragmentChatBinding? = null
    private val binding get() = _binding!!
    private lateinit var chatAdapter: ChatAdapter
    private val chatMessages = mutableListOf<ChatMessage>()
    private var isGreetingSent = false
    private val greetings = listOf(
        "Hello! How can I assist you today? üòä",
        "Hi there! What can I do for you? üòÑ",
        "Hey! Ready to help you out! üòÉ",
        "Good to see you! How can I assist? üòÅ",
        "Welcome back! What‚Äôs on your mind? üòä",
        "Hi! Let‚Äôs get started‚Äîwhat do you need help with? üòÑ",
        "Hello! How can I make your day better? üòä",
        "Hey! What‚Äôs up? How can I assist you? üòÉ",
        "Hi! Let‚Äôs tackle your questions together! üòÅ",
        "Hello! Ready to help you with anything! üòä"
    )
    private var rewardedAd: RewardedAd? = null
    private var canSendMessage = false
    private val client = OkHttpClient.Builder()
        .connectTimeout(30, TimeUnit.SECONDS)
        .readTimeout(30, TimeUnit.SECONDS)
        .writeTimeout(30, TimeUnit.SECONDS)
        .build()
    private val apiKey =  BuildConfig.API_KEY
    private var currentModel = "gpt-3.5-turbo"
    private var conversationId: String? = null
    private var tts: TextToSpeech? = null
    private var isTtsEnabled = false
    private val chatHistoryKey = "chat_history"
    private var isFollowUpEnabled = true

    private lateinit var expandFollowUpQuestionsButton: Button
    private lateinit var followUpQuestionsScrollView: HorizontalScrollView
    private var isFollowUpQuestionsExpanded = false

    private var subscriptionClickListener: OnSubscriptionClickListener? = null

    companion object {

        private const val REQUEST_IMAGE_CAPTURE = 1
        private const val CAMERA_REQUEST_CODE = 100
        private const val PERMISSION_REQUEST_CODE = 100
        private const val REQUEST_CODE_SPEECH_INPUT = 2
        private const val WRITE_EXTERNAL_STORAGE_PERMISSION_REQUEST_CODE = 105
        private const val PICK_DOCUMENT_REQUEST_CODE = 106
        private const val PICK_IMAGE_REQUEST_CODE = 107

        private const val PREFS_NAME = "prefs"
        private const val LAST_RESET_TIME_KEY = "last_reset_time"
        private const val MESSAGE_COUNT_KEY = "message_count"
        private const val DAILY_MESSAGE_LIMIT = 10

        // Define daily limits for each model
        private const val DAILY_LIMIT_GPT4 = 50
        private const val DAILY_LIMIT_DALLE = 20
        private const val DAILY_LIMIT_TTS = 30
        private const val DAILY_LIMIT_GEMINI = 40
        private const val DAILY_LIMIT_DEEPSEEK = 40
        //private const val REQUEST_RECORD_AUDIO_PERMISSION = 300
        private const val REQUEST_STORAGE_PERMISSION = 301
    }

    private lateinit var requestPermissionLauncher: ActivityResultLauncher<Array<String>>
    private lateinit var captureImageLauncher: ActivityResultLauncher<Intent>
    private lateinit var cropImageLauncher: ActivityResultLauncher<Intent>

    private val subscriptionViewModel: SubscriptionViewModel by activityViewModels()

    private var isUserSubscribed: Boolean = false
    private var subscriptionExpirationTime: Long = 0L

    private var suggestedMessage: String? = null
    private var selectedModel: String? = null

    interface OnSubscriptionClickListener {
        fun onSubscriptionClick()
    }

    override fun onAttach(context: Context) {
        super.onAttach(context)
        if (context is OnSubscriptionClickListener) {
            subscriptionClickListener = context
        } else {
            throw RuntimeException("$context must implement OnSubscriptionClickListener")
        }
    }

    override fun onDetach() {
        super.onDetach()
        subscriptionClickListener = null
    }

    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {

        _binding = FragmentChatBinding.inflate(inflater, container, false)
        setHasOptionsMenu(true) // Ensure the fragment can handle menu options
        return binding.root
    }


    override fun onCreateOptionsMenu(menu: Menu, inflater: MenuInflater) {
        inflater.inflate(R.menu.harmburger_menu, menu)
        super.onCreateOptionsMenu(menu, inflater)
    }

    override fun onResume() {
        super.onResume()
        (requireActivity() as? AppCompatActivity)?.supportActionBar?.apply {
            setDisplayHomeAsUpEnabled(true)
            setHomeAsUpIndicator(R.drawable.ic_arrow_back)
        }
        //loadInterstitialAd() // Load the interstitial ad when the fragment resumes
    }

    override fun onPause() {
        super.onPause()
        (requireActivity() as? AppCompatActivity)?.supportActionBar?.apply {
            setDisplayHomeAsUpEnabled(false)
        }
    }

    override fun onOptionsItemSelected(item: MenuItem): Boolean {
        return when (item.itemId) {
            R.id.menu_new_conversation -> {
                startNewConversation()
                true
            }
            R.id.menu_help -> {
                showHelpDialog()
                true
            }
            R.id.menu_report -> {
                showReportDialog()
                true
            }
            else -> super.onOptionsItemSelected(item)
        }
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        Log.d("ChatFragment", "onViewCreated called")

        selectedVoice = loadSelectedVoice()
        binding.voiceSelectionButton.text = "Voice: ${selectedVoice.replaceFirstChar { it.uppercase() }}"

        // Initialize the views
        expandFollowUpQuestionsButton = view.findViewById(R.id.expandFollowUpQuestionsButton)
        followUpQuestionsScrollView = view.findViewById(R.id.followUpQuestionsScrollView)

        // Set the click listener for the expand/collapse button
        expandFollowUpQuestionsButton.setOnClickListener {
            toggleFollowUpQuestions()
        }
        arguments?.getString("recognized_text")?.let { text ->
            binding.messageEditText.setText(text)
            binding.messageEditText.setSelection(text.length)
        }
        // Handle suggested message from arguments
        suggestedMessage = arguments?.getString("suggested_message")
        suggestedMessage?.let {
            binding.messageEditText.setText(it)
            binding.messageEditText.setSelection(it.length) // Move cursor to end
        }

        // Handle extracted text from arguments
        arguments?.getString("extracted_text")?.let { text ->
            setExtractedText(text)
        }


        // Check for email content in arguments
        arguments?.getString("email_content")?.let { emailContent ->
            binding.messageEditText.setText(emailContent)
        }

        binding.voiceSelectionButton.setTextColor(ContextCompat.getColor(requireContext(), android.R.color.white))
        // Initialize the chatAdapter with the lifecycleScope
        chatAdapter = ChatAdapter(chatMessages, binding, viewLifecycleOwner.lifecycleScope)

        binding.voiceSelectionButton.setOnClickListener {
            showVoiceSelectionDialog()
        }



        arguments?.getString("recognized_text")?.let { text ->
            binding.messageEditText.setText(text)
            binding.messageEditText.setSelection(text.length)
        }


        // Set up the RecyclerView
        binding.recyclerView.apply {
            layoutManager = LinearLayoutManager(requireContext()).apply {
                stackFromEnd = true // Ensure new messages appear at the bottom
            }
            adapter = chatAdapter
            setHasFixedSize(true) // Optimize for fixed-size RecyclerView
            itemAnimator = null // Disable item animations for better performance
            setItemViewCacheSize(20) // Increase cache size for smoother scrolling
        }
        // Load the isGreetingSent flag from SharedPreferences
        val sharedPreferences = requireContext().getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
        isGreetingSent = sharedPreferences.getBoolean(GREETING_SENT_KEY, false)

        // Now it's safe to send the greeting message
        if (!isGreetingSent) {
            sendGreetingMessage()
            isGreetingSent = true
            // Save the isGreetingSent flag to SharedPreferences
            sharedPreferences.edit().putBoolean(GREETING_SENT_KEY, true).apply()
        }

        updateActiveModelButton("GPT-3.5 Turbo")

        // Initialize TTS button state
        updateTtsButtonState()

        // Set up TTS toggle button click listener
        binding.ttsToggleButton.setOnClickListener {
            isTtsEnabled = !isTtsEnabled // Toggle the state
            updateTtsButtonState() // Update the button's appearance
            showCustomToast(if (isTtsEnabled) "TTS enabled" else "TTS disabled")
        }
        binding.activeModelButton.setOnClickListener {
            showChatGptOptionsDialog()
        }

        // Check if it's the first launch
        val isFirstLaunch = sharedPreferences.getBoolean(FIRST_LAUNCH_KEY, true)

        if (isFirstLaunch) {
            // Show the tooltip dialog
            val tooltipDialog = TooltipDialog()
            tooltipDialog.show(parentFragmentManager, "TooltipDialog")

            // Update the shared preferences to indicate that the dialog has been shown
            sharedPreferences.edit().putBoolean(FIRST_LAUNCH_KEY, false).apply()
        }

        suggestedMessage = arguments?.getString("suggested_message") ?: savedInstanceState?.getString("suggested_message")
        selectedModel = arguments?.getString("selected_model") ?: savedInstanceState?.getString("selected_model")

        if (suggestedMessage != null) {
            binding.messageEditText.setText(suggestedMessage)
            Log.d("ChatFragment", "Suggested message set: $suggestedMessage")
        }

        Log.d("ChatFragment", "Suggested message: $suggestedMessage")
        Log.d("ChatFragment", "Selected model: $selectedModel")

        val conversationId = arguments?.getString("conversation_id")
        initializeChat(selectedModel, conversationId)

        binding.historyButton.setOnClickListener {
            showChatHistoryDialog()
        }

        // Initialize with the selected model
        arguments?.getString("selected_model")?.let {
            currentModel = it
            updateUIForCurrentModel()
        }
        captureImageLauncher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) { result ->
            if (result.resultCode == Activity.RESULT_OK) {
                // Image was saved to currentPhotoPath, now process it
                val file = File(currentPhotoPath)
                if (file.exists()) {
                    // Add the image to the gallery
                    galleryAddPic(currentPhotoPath)

                    // Process the saved image file
                    val bitmap = BitmapFactory.decodeFile(currentPhotoPath)
                    if (bitmap != null) {
                        showImageProcessingOptions(bitmap)
                    } else {
                        showCustomToast("Failed to process captured image")
                    }
                } else {
                    showCustomToast("Image file not found")
                }
            } else {
                showCustomToast("Image capture cancelled")
            }
        }

        cropImageLauncher =
            registerForActivityResult(ActivityResultContracts.StartActivityForResult()) { result ->
                if (result.resultCode == Activity.RESULT_OK) {
                    val resultUri: Uri? = CropImage.getActivityResult(result.data)?.uri
                    if (resultUri != null) {
                        try {
                            val bitmap = ImageDecoder.decodeBitmap(
                                ImageDecoder.createSource(requireContext().contentResolver, resultUri)
                            )
                            showImageProcessingOptions(bitmap)
                        } catch (e: Exception) {
                            Log.e("ChatFragment", "Failed to decode bitmap from URI: ${e.message}")
                            showCustomToast("Failed to process the cropped image.")
                        }
                    } else {
                        Log.e("ChatFragment", "Cropped image URI is null.")
                        showCustomToast("Failed to retrieve the cropped image.")
                    }
                } else {
                    Log.e("ChatFragment", "Image cropping failed.")
                    showCustomToast("Image cropping failed.")
                }
            }

        requestPermissionLauncher = registerForActivityResult(
            ActivityResultContracts.RequestMultiplePermissions()
        ) { permissions ->
            val isCameraPermissionGranted = permissions[Manifest.permission.CAMERA] ?: false
            if (isCameraPermissionGranted) {
                dispatchTakePictureIntent()
            } else {
                Log.e("ChatFragment", "Camera permission denied.")
                showCustomToast("Camera permission is required to use this feature")
            }
        }

        //binding.followUpToggle.setOnCheckedChangeListener { _, isChecked ->
            //isFollowUpEnabled = isChecked
        //}

        // In your onViewCreated()
        binding.webView.apply {
            webViewClient = object : WebViewClient() {
                override fun shouldOverrideUrlLoading(view: WebView, url: String): Boolean {
                    // Handle URL loading within WebView
                    view.loadUrl(url)
                    return true
                }
            }
            settings.javaScriptEnabled = true
            settings.domStorageEnabled = true
        }

        (requireActivity() as? AppCompatActivity)?.supportActionBar?.title = "Chat with AITeacher"

        tts = TextToSpeech(requireContext(), this)

        binding.sendButton.setOnClickListener {
            val userMessage = binding.messageEditText.text.toString()
            Log.d("ChatFragment", "Send button clicked with message: $userMessage")
            if (userMessage.isNotEmpty()) {
                if (isUserSubscribed && subscriptionExpirationTime > System.currentTimeMillis() || canSendMessage) {
                    Log.d("ChatFragment", "User is subscribed or can send message")
                    handleMessage(userMessage)
                } else {
                    Log.d("ChatFragment", "User is not subscribed and cannot send message")
                    showRewardedAd()
                }
            } else {
                Log.d("ChatFragment", "User message is empty")
            }
        }

        binding.scanTextButton.setOnClickListener { showImageOrDocumentPickerDialog() }

        // Initialize speech recognizer with listener
        initializeSpeechRecognizer()


        binding.voiceInputButton.setOnClickListener {
            if (checkAndRequestPermissions()) {
                startVoiceRecognition()
            }
        }



        binding.shareButton.setOnClickListener { shareLastResponse() }

        binding.shareButton.background = ContextCompat.getDrawable(requireContext(), R.drawable.fading_background)
        binding.historyButton.background = ContextCompat.getDrawable(requireContext(), R.drawable.fading_background)
        arguments?.getString("suggested_message")?.let { suggestedMessage ->
            binding.messageEditText.setText(suggestedMessage)
        }

        loadChatHistory()

        arguments?.getString("conversation_json")?.let { conversationJson ->
            loadConversationFromJson(conversationJson)
        }

        PDFBoxResourceLoader.init(requireContext())

        requestPermissionLauncher = registerForActivityResult(
            ActivityResultContracts.RequestMultiplePermissions()
        ) { permissions ->
            val isWritePermissionGranted = permissions[Manifest.permission.WRITE_EXTERNAL_STORAGE] ?: false
            val isReadPermissionGranted = permissions[Manifest.permission.READ_EXTERNAL_STORAGE] ?: false

            if (isWritePermissionGranted || isReadPermissionGranted) {
                // Permissions granted
            } else {
                showCustomToast("Storage permission is required to save the document")
            }
        }

        subscriptionViewModel.isAdFree.observe(viewLifecycleOwner, Observer { isAdFree ->
            updateSubscriptionStatus(isAdFree, subscriptionViewModel.expirationTime.value ?: 0L)
        })

        subscriptionViewModel.expirationTime.observe(viewLifecycleOwner, Observer { expirationTime ->
            updateSubscriptionStatus(subscriptionViewModel.isAdFree.value ?: false, expirationTime)
        })

        binding.messageEditText.setOnTouchListener { _, event ->
            if (event.action == MotionEvent.ACTION_UP) {
                hideKeyboard()
                binding.messageEditText.clearFocus()
            }
            false
        }
        binding.messageEditText.customSelectionActionModeCallback = object : ActionMode.Callback {
            override fun onCreateActionMode(mode: ActionMode, menu: Menu): Boolean {
                menu.clear()
                mode.menuInflater.inflate(R.menu.custom_selection_menu, menu)
                return true
            }

            override fun onPrepareActionMode(mode: ActionMode, menu: Menu): Boolean {
                return false
            }

            override fun onActionItemClicked(mode: ActionMode, item: MenuItem): Boolean {
                return when (item.itemId) {
                    R.id.menu_copy -> {
                        copyHighlightedText()
                        mode.finish()
                        true
                    }
                    R.id.menu_delete -> {
                        deleteHighlightedText()
                        mode.finish()
                        true
                    }
                    else -> false
                }
            }

            override fun onDestroyActionMode(mode: ActionMode) {}
        }
        arguments?.getString("prefilled_question")?.let { question ->
            setQuestionText(question)
        }


        binding.sendButton.setOnClickListener {
            val userMessage = binding.messageEditText.text.toString()
            if (userMessage.isNotEmpty()) {
                hideKeyboard()
                if (isUserSubscribed && subscriptionExpirationTime > System.currentTimeMillis() || canSendMessage) {
                    handleMessage(userMessage)
                } else if (checkDailyMessageLimit()) {
                    incrementMessageCount()
                    handleMessage(userMessage)
                } else {
                    showRewardedAd()
                }
            }
        }

        binding.messageEditText.customSelectionActionModeCallback = object : ActionMode.Callback {
            override fun onCreateActionMode(mode: ActionMode, menu: Menu): Boolean {
                menu.clear()
                mode.menuInflater.inflate(R.menu.custom_selection_menu, menu)
                return true
            }

            override fun onPrepareActionMode(mode: ActionMode, menu: Menu): Boolean {
                return false
            }

            override fun onActionItemClicked(mode: ActionMode, item: MenuItem): Boolean {
                return when (item.itemId) {
                    R.id.menu_copy -> {
                        copyHighlightedText()
                        mode.finish()
                        true
                    }
                    else -> false
                }
            }

            override fun onDestroyActionMode(mode: ActionMode) {}
        }

        // Retrieve subscription status from arguments
        val isAdFree = arguments?.getBoolean("is_ad_free", false) ?: false
        val expirationTime = arguments?.getLong("expiration_time", 0) ?: 0
        updateSubscriptionStatus(isAdFree, expirationTime)
    }

    override fun onSaveInstanceState(outState: Bundle) {
        super.onSaveInstanceState(outState)
        outState.putString("suggested_message", suggestedMessage)
        outState.putString("selected_model", selectedModel)
    }

    private fun updateUIForCurrentModel() {
        when (currentModel) {
            "dall-e-3" -> {
                binding.messageEditText.hint = "Describe the image you want to generate..."
                binding.followUpQuestionsContainer.visibility = View.GONE
                binding.generatedImageView.visibility = View.VISIBLE
                updateActiveModelButton("DALL-E 3")
            }
            else -> {
                binding.messageEditText.hint = "Type your message here..."
                binding.followUpQuestionsContainer.visibility = View.VISIBLE
                binding.generatedImageView.visibility = View.GONE
                updateActiveModelButton(when(currentModel) {
                    "gpt-4" -> "GPT-4"
                    else -> "GPT-3.5 Turbo"
                })
            }
        }
    }



    private fun addFollowUpQuestionsToChat(questions: List<String>) {
        binding.followUpQuestionsContainer.removeAllViews()

        if (!isFollowUpEnabled || questions.isEmpty()) {
            binding.followUpQuestionsContainer.visibility = View.GONE
            return
        }

        // Create the toggle header button
        val toggleButton = Button(requireContext()).apply {
            //text = "Suggested Follow-ups ‚ñº"
            textSize = 14f
            setTypeface(typeface, Typeface.BOLD)
            setBackgroundColor(Color.TRANSPARENT)
            setTextColor(ContextCompat.getColor(requireContext(), R.color.primary_color))

            val params = LinearLayout.LayoutParams(
                ViewGroup.LayoutParams.MATCH_PARENT,
                ViewGroup.LayoutParams.WRAP_CONTENT
            ).apply {
                setMargins(0, 0, 0, (8 * resources.displayMetrics.density).toInt())
            }
            layoutParams = params
        }

        // Create container for questions (initially hidden)
        val questionsContainer = LinearLayout(requireContext()).apply {
            orientation = LinearLayout.VERTICAL
            visibility = View.GONE
        }

        // Add questions to the container
        questions.forEach { question ->
            Button(requireContext()).apply {
                text = question
                textSize = 12f
                setTypeface(typeface, Typeface.NORMAL)
                setBackgroundColor(Color.TRANSPARENT)
                setTextColor(ContextCompat.getColor(requireContext(), R.color.primary_color))

                val params = LinearLayout.LayoutParams(
                    ViewGroup.LayoutParams.MATCH_PARENT,
                    ViewGroup.LayoutParams.WRAP_CONTENT
                ).apply {
                    setMargins(0, 0, 0, (4 * resources.displayMetrics.density).toInt())
                }
                layoutParams = params

                setOnClickListener {
                    binding.messageEditText.setText(question)
                    binding.messageEditText.setSelection(question.length)
                }
            }.also { questionsContainer.addView(it) }
        }

        // Toggle functionality
        var isExpanded = false
        toggleButton.setOnClickListener {
            isExpanded = !isExpanded
            if (isExpanded) {
                questionsContainer.visibility = View.VISIBLE
                toggleButton.text = "Suggested Follow-ups ‚ñ≤"
                questionsContainer.animate()
                    .alpha(1f)
                    .setDuration(200)
                    .start()
            } else {
                questionsContainer.animate()
                    .alpha(0f)
                    .setDuration(200)
                    .withEndAction {
                        questionsContainer.visibility = View.GONE
                    }
                    .start()
                toggleButton.text = "Suggested Follow-ups ‚ñº"
            }
        }

        // Add views to container
        binding.followUpQuestionsContainer.addView(toggleButton)
        binding.followUpQuestionsContainer.addView(questionsContainer)
        binding.followUpQuestionsContainer.visibility = View.VISIBLE
    }


    private fun sendMessageToAPI(message: String) {
        when (currentModel) {
            "dall-e-3" -> handleImageGeneration(message)
            else -> {
                handleChatCompletion(message)
            }
        }
    }

    private fun handleReasoningModelCompletion(message: String, model: String) {
        val messagesArray = JSONArray().apply {
            put(JSONObject().apply {
                put("role", "user")
                put("content", message)
            })
        }

        val json = JSONObject().apply {
            put("model", model)
            put("reasoning_effort", "medium") // Set the reasoning_effort parameter
            put("messages", messagesArray)
        }

        val body = json.toString().toRequestBody("application/json; charset=utf-8".toMediaTypeOrNull())
        val request = Request.Builder()
            .url("https://api.openai.com/v1/chat/completions")
            .post(body)
            .addHeader("Authorization", "Bearer $apiKey")
            .addHeader("Content-Type", "application/json")
            .build()

        Log.d("ChatFragment", "Sending request: $json")

        showTypingIndicator()

        lifecycleScope.launch {
            try {
                val response = withContext(Dispatchers.IO) {
                    client.newCall(request).execute()
                }

                val responseBody = response.body?.string()
                Log.d("ChatFragment", "Received response: $responseBody")

                if (!response.isSuccessful) {
                    Log.e("ChatFragment", "Unexpected code $response")
                    withContext(Dispatchers.Main) {
                        when (response.code) {
                            400 -> showCustomToast("Bad Request: Check your request parameters")
                            401 -> showCustomToast("Unauthorized: Check your API key")
                            403 -> showCustomToast("Forbidden: You don't have permission to access this resource")
                            500 -> showCustomToast("Server Error: Try again later")
                            // else -> showCustomToast("Unexpected response from server")
                        }
                        removeTypingIndicator()
                    }
                    return@launch
                }

                responseBody?.let {
                    try {
                        val jsonResponse = JSONObject(it)
                        Log.d("ChatFragment", "Parsed JSON response: $jsonResponse")
                        if (jsonResponse.has("choices")) {
                            val choices = jsonResponse.getJSONArray("choices")
                            if (choices.length() > 0) {
                                val reply = choices.getJSONObject(0).getJSONObject("message")
                                    .getString("content").trim()
                                withContext(Dispatchers.Main) {
                                    removeTypingIndicator()
                                    chatMessages.add(
                                        ChatMessage(
                                            id = System.currentTimeMillis().toString(), // Generate a unique ID
                                            content = reply,
                                            isUser = false
                                        )
                                    )
                                    chatAdapter.notifyItemInserted(chatMessages.size - 1)
                                    binding.recyclerView.smoothScrollToPosition(chatMessages.size - 1)
                                    //generateFollowUpQuestions(reply)
                                    // Only trigger TTS if the toggle is enabled
                                    if (isTtsEnabled) {
                                        handleTextToSpeech(reply)
                                    }
                                    incrementInteractionCount()
                                }
                            } else {
                                withContext(Dispatchers.Main) {
                                    showCustomToast("No choices found in the response")
                                    removeTypingIndicator()
                                }
                            }
                        } else {
                            withContext(Dispatchers.Main) {
                                showCustomToast("No choices found in the response")
                                removeTypingIndicator()
                            }
                        }
                    } catch (e: JSONException) {
                        Log.e("ChatFragment", "Failed to parse response", e)
                        withContext(Dispatchers.Main) {
                            showCustomToast("Failed to parse response")
                            removeTypingIndicator()
                        }
                    }
                }
            } catch (e: IOException) {
                Log.e("ChatFragment", "Failed to get response", e)
                withContext(Dispatchers.Main) {
                    showCustomToast("Failed to get response")
                    removeTypingIndicator()
                }
            }
        }
    }

    private fun handleChatCompletion(message: String) {
        val messagesArray = JSONArray().apply {
            // Handle developer messages for reasoning models
            if (currentModel.startsWith("o")) {
                put(JSONObject().apply {
                    put("role", "developer")  // Use developer role instead of system
                    put("content", "You are a helpful assistant")
                })
            }

            // Add existing chat history
            for (chatMessage in chatMessages) {
                put(JSONObject().apply {
                    put("role", if (chatMessage.isUser) "user" else "assistant")
                    put("content", chatMessage.content)
                })
            }

            // Add new user message
            put(JSONObject().apply {
                put("role", "user")
                put("content", message)
            })
        }

        val json = JSONObject().apply {
            put("model", currentModel)
            put("messages", messagesArray)
            // Add web search options if enabled and using a web search model
            if  (isWebSearchEnabled && WEB_SEARCH_MODELS.contains(currentModel)) {
                put("web_search_options", JSONObject().apply {
                    // Default search context size
                    put("search_context_size", "medium")
                    // Optional: Add user location if available
                    /*
                    put("user_location", JSONObject().apply {
                        put("type", "approximate")
                        put("approximate", JSONObject().apply {
                            put("country", "US") // ISO country code
                            put("city", "New York")
                            put("region", "NY")
                        })
                    })
                    */
                })
            }

            // Add reasoning parameters for supported models
            when (currentModel) {
                "gpt-4o-search-preview", "gpt-4o-mini-search-preview" -> {
                    // Web search models don't need additional parameters
                }
                "o1", "o3-mini" -> {
                    put("reasoning_effort", "medium")  // Valid values: low, medium, high
                    put("max_completion_tokens", 4096) // Manage total tokens (reasoning + response)
                }
            }
        }

        val body = json.toString().toRequestBody("application/json; charset=utf-8".toMediaTypeOrNull())
        val request = Request.Builder()
            .url("https://api.openai.com/v1/chat/completions")
            .post(body)
            .addHeader("Authorization", "Bearer $apiKey")
            .addHeader("Content-Type", "application/json")
            .build()

        Log.d("ChatFragment", "Sending request: $json")

        showTypingIndicator()

        lifecycleScope.launch {
            try {
                val response = withContext(Dispatchers.IO) {
                    client.newCall(request).execute()
                }

                val responseBody = response.body?.string()
                Log.d("ChatFragment", "Received response: $responseBody")

                if (!response.isSuccessful) {
                    handleErrorResponse(response)
                    return@launch
                }

                responseBody?.let { handleSuccessResponse(it) }
            } catch (e: IOException) {
                handleNetworkError(e)
            }
        }
    }
    private fun handleErrorResponse(response: Response) {
        lifecycleScope.launch(Dispatchers.Main) {
            val errorMessage = when (response.code) {
                400 -> {
                    if (currentModel.startsWith("o")) {
                        "Insufficient context window for reasoning tokens"
                    } else {
                        "Bad request: Check parameters"
                    }
                }
                401 -> "Unauthorized: Check API key"
                403 -> "Forbidden: Access denied"
                429 -> "Rate limit exceeded"
                500 -> "Server error"
                503 -> "Service unavailable"
                else -> "Unexpected error: ${response.code}"
            }
            showCustomToast(errorMessage)
            removeTypingIndicator()
        }
    }

    private fun handleSuccessResponse(responseBody: String) {
        try {
            val jsonResponse = JSONObject(responseBody)
            val choices = jsonResponse.optJSONArray("choices")
            val usage = jsonResponse.optJSONObject("usage")

            lifecycleScope.launch(Dispatchers.Main) {
                removeTypingIndicator()

                if (choices != null && choices.length() > 0) {
                    val choice = choices.getJSONObject(0)
                    val messageObj = choice.getJSONObject("message")
                    var reply = messageObj.getString("content").trim()
                    val citations = mutableListOf<Citation>()
                    val followUpQuestions = mutableListOf<String>()

                    // Handle web search citations if present
                    if (messageObj.has("annotations")) {
                        val annotations = messageObj.getJSONArray("annotations")
                        for (i in 0 until annotations.length()) {
                            val annotation = annotations.getJSONObject(i)
                            if (annotation.getString("type") == "url_citation") {
                                val citation = annotation.getJSONObject("url_citation")
                                citations.add(
                                    Citation(
                                        url = citation.getString("url"),
                                        title = citation.optString("title", "Source"),
                                        startIndex = citation.getInt("start_index"),
                                        endIndex = citation.getInt("end_index")
                                    )
                                )
                            }
                            // Extract follow-up questions from annotations if available
                            if (annotation.getString("type") == "follow_up") {
                                val followUp = annotation.getJSONObject("follow_up")
                                followUpQuestions.add(followUp.getString("question"))
                            }
                        }
                    }

                    // Format the reply with citations if web search was used
                    if (citations.isNotEmpty()) {
                        val spannable = SpannableString(reply)

                        for (citation in citations.sortedByDescending { it.startIndex }) {
                            try {
                                val clickableSpan = object : ClickableSpan() {
                                    override fun onClick(widget: View) {
                                        showCitationDialog(citation)
                                    }
                                }
                                spannable.setSpan(
                                    clickableSpan,
                                    citation.startIndex,
                                    citation.endIndex,
                                    Spannable.SPAN_EXCLUSIVE_EXCLUSIVE
                                )
                                spannable.setSpan(
                                    ForegroundColorSpan(Color.BLUE),
                                    citation.startIndex,
                                    citation.endIndex,
                                    Spannable.SPAN_EXCLUSIVE_EXCLUSIVE
                                )
                                spannable.setSpan(
                                    UnderlineSpan(),
                                    citation.startIndex,
                                    citation.endIndex,
                                    Spannable.SPAN_EXCLUSIVE_EXCLUSIVE
                                )
                            } catch (e: Exception) {
                                Log.e("ChatFragment", "Error formatting citation", e)
                            }
                        }

                        reply = "üîç Web Search Results:\n\n$reply"
                    }

                    // Handle reasoning token usage
                    val reasoningTokens = usage?.optJSONObject("completion_tokens_details")
                        ?.optInt("reasoning_tokens") ?: 0
                    Log.d("ChatFragment", "Used $reasoningTokens reasoning tokens")

                    // Generate dynamic follow-up questions if none were provided
                    if (followUpQuestions.isEmpty()) {
                        generateDynamicFollowUpQuestions(reply) { generatedQuestions ->
                            followUpQuestions.addAll(generatedQuestions)

                            chatMessages.add(
                                ChatMessage(
                                    id = System.currentTimeMillis().toString(),
                                    content = reply,
                                    isUser = false,
                                    citations = citations,
                                    followUpQuestions = followUpQuestions
                                )
                            )
                            chatAdapter.notifyItemInserted(chatMessages.size - 1)
                            binding.recyclerView.smoothScrollToPosition(chatMessages.size - 1)

                            addFollowUpQuestionsToChat(followUpQuestions)
                        }
                    } else {
                        chatMessages.add(
                            ChatMessage(
                                id = System.currentTimeMillis().toString(),
                                content = reply,
                                isUser = false,
                                citations = citations,
                                followUpQuestions = followUpQuestions
                            )
                        )
                        chatAdapter.notifyItemInserted(chatMessages.size - 1)
                        binding.recyclerView.smoothScrollToPosition(chatMessages.size - 1)

                        addFollowUpQuestionsToChat(followUpQuestions)
                    }

                    if (isTtsEnabled) {
                        handleTextToSpeech(reply)
                    }
                    incrementInteractionCount()
                } else {
                    showCustomToast("No valid response from API")
                }
            }
        } catch (e: JSONException) {
            lifecycleScope.launch(Dispatchers.Main) {
                showCustomToast("Failed to parse response")
                removeTypingIndicator()
            }
        }
    }

    private fun generateDynamicFollowUpQuestions(reply: String, callback: (List<String>) -> Unit) {
        val prompt = """
        Based on the following AI response, generate 3 relevant follow-up questions 
        that would help continue the conversation. Return them as a JSON array of strings.
        
        Response: $reply
        
        Example format: ["Question 1", "Question 2", "Question 3"]
    """.trimIndent()

        val messagesArray = JSONArray().apply {
            put(JSONObject().apply {
                put("role", "user")
                put("content", prompt)
            })
        }

        val json = JSONObject().apply {
            put("model", "gpt-3.5-turbo") // Use a lightweight model for this
            put("messages", messagesArray)
            put("temperature", 0.7)
            put("max_tokens", 150)
        }

        val request = Request.Builder()
            .url("https://api.openai.com/v1/chat/completions")
            .post(json.toString().toRequestBody("application/json; charset=utf-8".toMediaTypeOrNull()))
            .addHeader("Authorization", "Bearer $apiKey")
            .build()

        lifecycleScope.launch(Dispatchers.IO) {
            try {
                val response = client.newCall(request).execute()
                if (response.isSuccessful) {
                    val responseBody = response.body?.string()
                    val jsonResponse = JSONObject(responseBody!!)
                    val content = jsonResponse.getJSONArray("choices")
                        .getJSONObject(0)
                        .getJSONObject("message")
                        .getString("content")

                    // Parse the JSON array from the response
                    val questions = try {
                        JSONArray(content).let { array ->
                            List(array.length()) { array.getString(it) }
                        }
                    } catch (e: Exception) {
                        // Fallback to parsing as plain text if JSON parsing fails
                        content.split("\n")
                            .map { it.trim() }
                            .filter { it.isNotBlank() && it.startsWith("\"") && it.endsWith("\"") }
                            .map { it.removeSurrounding("\"") }
                    }

                    withContext(Dispatchers.Main) {
                        callback(questions.take(3)) // Ensure we only return 3 questions
                    }
                } else {
                    withContext(Dispatchers.Main) {
                        callback(emptyList()) // Fallback to no questions if API fails
                    }
                }
            } catch (e: Exception) {
                Log.e("ChatFragment", "Error generating follow-up questions", e)
                withContext(Dispatchers.Main) {
                    callback(emptyList()) // Fallback to no questions on error
                }
            }
        }
    }
    private fun handleNetworkError(e: IOException) {
        lifecycleScope.launch(Dispatchers.Main) {
            showCustomToast("Network error: ${e.message}")
            removeTypingIndicator()
        }
    }

    private fun playAudioFromFile(file: File) {
        val mediaPlayer = MediaPlayer().apply {
            setDataSource(file.absolutePath)
            prepare()
            start()
        }
    }

    private fun handleImageGeneration(prompt: String, retryCount: Int = 3) {
        if (!isNetworkAvailable()) {
            showCustomToast("No internet connection. Please check your network settings.")
            return
        }

        // Show "Generating..." text and hide other elements
        binding.generatingText.visibility = View.VISIBLE
        binding.generatedImageView.visibility = View.GONE
        binding.downloadButton.visibility = View.GONE

        // Start the "Generating..." animation
        startGeneratingAnimation()

        val json = JSONObject().apply {
            put("model", "dall-e-3")
            put("prompt", prompt)
            put("n", 1)
            put("size", "1024x1024")
            put("quality", "standard")
            put("style", "vivid")
        }

        val body = json.toString().toRequestBody("application/json; charset=utf-8".toMediaTypeOrNull())
        val request = Request.Builder()
            .url("https://api.openai.com/v1/images/generations")
            .post(body)
            .addHeader("Authorization", "Bearer $apiKey")
            .build()

        client.newCall(request).enqueue(object : Callback {
            override fun onFailure(call: Call, e: IOException) {
                if (retryCount > 0) {
                    Log.d("ChatFragment", "Retrying image generation... Attempts left: $retryCount")
                    handleImageGeneration(prompt, retryCount - 1)
                } else {
                    Log.e("ChatFragment", "Failed to get image generation response", e)
                    requireActivity().runOnUiThread {
                        showCustomToast("Failed to generate image. Please check your internet connection.")
                        binding.generatingText.visibility = View.GONE
                        binding.downloadButton.visibility = View.GONE

                        // Stop the "Generating..." animation on failure
                        stopGeneratingAnimation()
                    }
                }
            }

            override fun onResponse(call: Call, response: Response) {
                if (!response.isSuccessful || response.body == null) {
                    Log.e("ChatFragment", "Unexpected code $response")
                    requireActivity().runOnUiThread {
                        showCustomToast("Unexpected response from image generation API")
                        binding.generatingText.visibility = View.GONE
                        binding.downloadButton.visibility = View.GONE

                        // Stop the "Generating..." animation on error
                        stopGeneratingAnimation()
                    }
                    return
                }

                val responseBody = response.body?.string()
                Log.d("ChatFragment", "Received response: $responseBody")

                try {
                    val jsonResponse = JSONObject(responseBody)
                    val data = jsonResponse.getJSONArray("data")
                    if (data.length() > 0) {
                        val imageUrl = data.getJSONObject(0).getString("url")
                        val revisedPrompt = data.getJSONObject(0).optString("revised_prompt", prompt)

                        requireActivity().runOnUiThread {
                            // Display the generated image
                            Glide.with(this@ChatFragment)
                                .load(imageUrl)
                                .into(binding.generatedImageView)
                            binding.generatedImageView.visibility = View.VISIBLE

                            // Show the download button and change its color to green
                            binding.downloadButton.visibility = View.VISIBLE
                            binding.downloadButton.backgroundTintList = ContextCompat.getColorStateList(requireContext(), R.color.green)
                            binding.downloadButton.setOnClickListener {
                                downloadImage(imageUrl)
                            }

                            // Hide the "Generating..." text and stop the animation
                            binding.generatingText.visibility = View.GONE
                            stopGeneratingAnimation()
                        }
                    } else {
                        requireActivity().runOnUiThread {
                            showCustomToast("No image generated")
                            binding.generatingText.visibility = View.GONE
                            binding.downloadButton.visibility = View.GONE

                            // Stop the "Generating..." animation if no image is generated
                            stopGeneratingAnimation()
                        }
                    }
                } catch (e: JSONException) {
                    Log.e("ChatFragment", "Failed to parse image generation response", e)
                    requireActivity().runOnUiThread {
                        showCustomToast("Failed to parse image generation response")
                        binding.generatingText.visibility = View.GONE
                        binding.downloadButton.visibility = View.GONE

                        // Stop the "Generating..." animation on parsing error
                        stopGeneratingAnimation()
                    }
                }
            }
        })
    }

    private fun incrementChatCount() {
        val sharedPreferences = requireContext().getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
        val chatCount = sharedPreferences.getInt(CHAT_COUNT_KEY, 0)
        sharedPreferences.edit().putInt(CHAT_COUNT_KEY, chatCount + 1).apply()
    }

    private fun getChatCount(): Int {
        val sharedPreferences = requireContext().getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
        return sharedPreferences.getInt(CHAT_COUNT_KEY, 0)
    }

    private fun checkAndShowSubscriptionPrompt() {
        if (!isUserSubscribed && getChatCount() >= SUBSCRIPTION_PROMPT_THRESHOLD) {
            showSubscriptionPrompt()
        }
    }

    private fun showSubscriptionPrompt() {
        val dialogView = LayoutInflater.from(requireContext()).inflate(R.layout.dialog_subscription_app, null)
        val title: TextView = dialogView.findViewById(R.id.title)
        val message: TextView = dialogView.findViewById(R.id.message)
        val lottieAnimationView: LottieAnimationView = dialogView.findViewById(R.id.lottieAnimationView)

        title.text = "Buy Now! üéâ"
        message.text = Html.fromHtml(
            "<font color='#008000'><b>Enjoy unlimited chat</b></font>.<br><br>" +
                    "Unlock all features and enjoy an ad-free experience. üõí<br><br>" +
                    "Create your own EBook, your own APP with personalized features, generate stunning pictures, wallpapers, icons from simple text. ‚ú®<br><br>" +
                    "<b>Learn anything</b> with our powerful models, from <b>maths</b> and <b>science</b> to <b>coding</b>. üìöüí°<br><br>" +
                    "Buy now and get access to all these premium features and more! üöÄ"
        )

        val dialog = AlertDialog.Builder(requireContext())
            .setView(dialogView)
            .setPositiveButton("Buy") { dialog, which ->
                subscriptionClickListener?.onSubscriptionClick()
            }
            .setNegativeButton("Cancel", null)
            .create()

        dialog.setOnShowListener {
            val positiveButton = dialog.getButton(AlertDialog.BUTTON_POSITIVE)
            val negativeButton = dialog.getButton(AlertDialog.BUTTON_NEGATIVE)

            // Customize the buttons
            positiveButton.setTextColor(Color.WHITE)
            positiveButton.setBackgroundColor(Color.parseColor("#FF9800")) // Solid orange color
            negativeButton.setTextColor(Color.BLACK)
            negativeButton.setBackgroundColor(Color.LTGRAY)

            // Set layout parameters with weight
            val layoutParams = LinearLayout.LayoutParams(
                0, // Width set to 0dp to use weight
                LinearLayout.LayoutParams.WRAP_CONTENT
            ).apply {
                weight = 1f // Equal weight distribution
                setMargins(16, 8, 16, 8)
            }

            positiveButton.layoutParams = layoutParams
            negativeButton.layoutParams = layoutParams

            // Set parent background
            val parent = positiveButton.parent as View
            parent.setBackgroundColor(Color.WHITE)

            // Animation (unchanged)
            val animator = ObjectAnimator.ofFloat(positiveButton, "translationY", 0f, 10f, 0f)
            animator.duration = 1000
            animator.repeatCount = ObjectAnimator.INFINITE
            animator.start()
        }

        dialog.show()
    }

    private fun startGeneratingAnimation() {
        val blinkAnimation = AnimationUtils.loadAnimation(requireContext(), R.anim.blink)
        binding.generatingText.startAnimation(blinkAnimation)
    }

    private fun stopGeneratingAnimation() {
        binding.generatingText.clearAnimation()
    }

    private fun downloadImage(imageUrl: String) {
        lifecycleScope.launch {
            try {
                val response = withContext(Dispatchers.IO) {
                    client.newCall(Request.Builder().url(imageUrl).build()).execute()
                }

                if (!response.isSuccessful || response.body == null) {
                    Log.e("ChatFragment", "Failed to download image")
                    withContext(Dispatchers.Main) {
                        showCustomToast("Failed to download image")
                    }
                    return@launch
                }

                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
                    saveImageUsingMediaStore(response.body!!.byteStream())
                } else {
                    saveImageUsingFileSystem(response.body!!.byteStream())
                }
            } catch (e: IOException) {
                Log.e("ChatFragment", "Failed to download image", e)
                withContext(Dispatchers.Main) {
                    showCustomToast("Failed to download image")
                }
            }
        }
    }

    @RequiresApi(Build.VERSION_CODES.Q)
    private suspend fun saveImageUsingMediaStore(inputStream: InputStream) {
        withContext(Dispatchers.IO) {
            val fileName = "generated_image_${System.currentTimeMillis()}.png"

            val contentValues = ContentValues().apply {
                put(MediaStore.Images.Media.DISPLAY_NAME, fileName)
                put(MediaStore.Images.Media.MIME_TYPE, "image/png")
                put(MediaStore.Images.Media.RELATIVE_PATH, Environment.DIRECTORY_PICTURES)
            }

            val resolver = requireContext().contentResolver
            val imageUri = resolver.insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, contentValues)

            if (imageUri != null) {
                resolver.openOutputStream(imageUri)?.use { outputStream ->
                    inputStream.copyTo(outputStream)
                }
                withContext(Dispatchers.Main) {
                    showCustomToast("Image saved to Pictures directory")
                }
            } else {
                withContext(Dispatchers.Main) {
                    showCustomToast("Failed to save image")
                }
            }
        }
    }

    private suspend fun saveImageUsingFileSystem(inputStream: InputStream) {
        withContext(Dispatchers.IO) {
            val fileName = "generated_image_${System.currentTimeMillis()}.png"
            val file = File(
                Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_PICTURES),
                fileName
            )

            FileOutputStream(file).use { outputStream ->
                inputStream.copyTo(outputStream)
            }

            withContext(Dispatchers.Main) {
                showCustomToast("Image saved to ${file.absolutePath}")
            }
        }
    }

    private fun handleMessage(message: String) {
        val response = generateResponse(message)
        when (currentModel) {
            "dall-e-3" -> {
                if (checkDailyLimit("dall-e-3", DAILY_LIMIT_DALLE)) {
                    addMessageToChat(message, true)
                    handleImageGeneration(message)
                    binding.messageEditText.text.clear()
                    incrementModelUsage("dall-e-3")
                } else {
                    showCustomToast("Daily limit for DALL-E 3 reached.")
                }
            }
            "gemini" -> {
                if (checkDailyLimit("gemini", DAILY_LIMIT_GEMINI)) {
                    addMessageToChat(message, true)
                    handleGeminiCompletion(message)
                    binding.messageEditText.text.clear()
                    incrementModelUsage("gemini")
                } else {
                    showCustomToast("Daily limit for Gemini reached.")
                }
            }
            "deepseek" -> {
                if (checkDailyLimit("deepseek", DAILY_LIMIT_DEEPSEEK)) {
                    addMessageToChat(message, true)
                    handleDeepSeekCompletion(message)
                    binding.messageEditText.text.clear()
                    incrementModelUsage("deepseek")
                } else {
                    showCustomToast("Daily limit for DeepSeek reached.")
                }
            }
            "o3-mini" -> {
                if (checkDailyLimit("o3-mini", DAILY_LIMIT_GPT4)) {
                    addMessageToChat(message, true)
                    handleReasoningModelCompletion(message, "o3-mini")
                    binding.messageEditText.text.clear()
                    incrementModelUsage("o3-mini")
                } else {
                    showCustomToast("Daily limit for O3 Mini reached.")
                }
            }
            else -> {
                addMessageToChat(message, true)
                if (isUserSubscribed && subscriptionExpirationTime > System.currentTimeMillis() || canSendMessage) {
                    sendMessageToAPI(response)
                    binding.messageEditText.text.clear()
                    if (!isUserSubscribed) {
                        canSendMessage = false
                    }
                } else if (checkDailyMessageLimit()) {
                    incrementMessageCount()
                    sendMessageToAPI(response)
                    binding.messageEditText.text.clear()
                } else {
                    //showInterstitialAd() // Show interstitial ad if daily message limit is reached
                }
                incrementChatCount()
                checkAndShowSubscriptionPrompt()
            }
        }
    }

    private fun handleDalle3Request(message: String) {
        addMessageToChat(message, true)
        handleImageGeneration(message)
        binding.messageEditText.text.clear()
        incrementModelUsage("dall-e-3")
    }

    private fun showSubscriptionRequiredDialog() {
        AlertDialog.Builder(requireContext())
            .setTitle("Subscription Required")
            .setMessage("This feature requires an active subscription")
            .setPositiveButton("Subscribe") { _, _ ->
                subscriptionClickListener?.onSubscriptionClick()
            }
            .setNegativeButton("Cancel", null)
            .show()
    }

    private fun addMessageToChat(message: String, isUser: Boolean) {
        val newChatMessages = chatMessages.toMutableList()
        newChatMessages.add(
            ChatMessage(
                id = System.currentTimeMillis().toString(), // Generate a unique ID
                content = message,
                isUser = isUser
            )
        )
        chatAdapter.updateChatMessages(newChatMessages)
        binding.recyclerView.smoothScrollToPosition(newChatMessages.size - 1)
        saveChatHistory()

        if (!isUser && isTtsEnabled) {
            speakOut(message)
        }
    }
    private fun generateResponse(userQuery: String): String {
        val baseResponse = "Here is the explanation for your query: $userQuery"
        val needsDiagramKeywords = listOf("diagram", "sketch", "draw", "looks like", "visualize", "illustrate", "chart", "graph")

        val needsDiagram = needsDiagramKeywords.any { keyword ->
            userQuery.contains(keyword, ignoreCase = true)
        }

        return if (needsDiagram) {
            val searchQuery = userQuery.replace(" ", "+")
            val searchUrl = "https://www.google.com/search?q=$searchQuery+diagram"
            "$baseResponse<br>As an AI, I am text-based and cannot provide clickable links or visual content directly. However, you can find relevant diagrams and sketches by visiting: <a href=\"$searchUrl\">this link</a>."
        } else {
            baseResponse
        }
    }
    private fun speakOut(text: String) {
        if (isTtsEnabled) {
            tts?.speak(text, TextToSpeech.QUEUE_FLUSH, null, "")
        }
    }

    private fun isNetworkAvailable(): Boolean {
        val connectivityManager = requireContext().getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager
        val activeNetworkInfo = connectivityManager.activeNetworkInfo
        return activeNetworkInfo != null && activeNetworkInfo.isConnected
    }

    private fun generateFollowUpQuestions(response: String) {
        val prompt = "Based on the following response, generate 3 follow-up questions that the user can send to openAI for an answer: $response"

        sendMessageToChatGPT(prompt) { followUpResponse ->
            val questions = followUpResponse.split("\n").filter { it.isNotBlank() }
            requireActivity().runOnUiThread {
                addFollowUpQuestionsToChat(questions)
            }
        }
    }

    private fun loadRewardedAd() {
        val adRequest = AdRequest.Builder().build()
        RewardedAd.load(
            requireContext(),
            "ca-app-pub-9180832030816304/2247664120",
            adRequest,
            object : RewardedAdLoadCallback() {
                override fun onAdFailedToLoad(adError: LoadAdError) {
                    Log.d("ChatFragment", adError.message)
                    rewardedAd = null
                }

                override fun onAdLoaded(ad: RewardedAd) {
                    Log.d("ChatFragment", "Ad was loaded.")
                    rewardedAd = ad
                }
            }
        )
    }

    private fun showRewardedAd() {
        if (!isUserSubscribed) {
            rewardedAd?.let { ad ->
                ad.show(requireActivity()) { rewardItem: RewardItem ->
                    Log.d("ChatFragment", "User earned the reward.")
                    canSendMessage = true
                    showCustomToast("You can now send a message.")
                    loadRewardedAd()
                }
            } ?: run {
                Log.d("ChatFragment", "The rewarded ad wasn't ready yet.")
                showCustomToast("Free Daily usage is finished.Buy now!& Enjoy unlimited Chat!!")
                loadRewardedAd()
            }
        } else {
            showExtraToast("The ad is not ready yet. Please try again later.")
        }
    }

    private fun showExtraToast(message: String) {
        val inflater = layoutInflater
        val layout: View = inflater.inflate(R.layout.extra_toast, null)

        val text: TextView = layout.findViewById(R.id.toast_text)
        text.text = message

        val toast = Toast(requireContext())
        toast.duration = Toast.LENGTH_LONG
        toast.view = layout
        toast.show()
    }

    private fun showCustomToast(message: String) {
        if (isAdded) {
            Toast.makeText(requireContext(), message, Toast.LENGTH_SHORT).show()
        } else {
            Log.w("ChatFragment", "Cannot show toast: Fragment not attached to context.")
        }
    }


    private fun sendMessageToChatGPT(prompt: String, callback: (String) -> Unit) {
        val messagesArray = JSONArray().apply {
            put(JSONObject().apply {
                put("role", "user")
                put("content", prompt)
            })
        }

        val json = JSONObject().apply {
            put("model", currentModel)
            put("messages", messagesArray)
            if (currentModel == "o1" || currentModel == "o3-mini") {
                put("reasoning_effort", "medium")
            }
        }

        val body = json.toString().toRequestBody("application/json; charset=utf-8".toMediaTypeOrNull())
        val request = Request.Builder()
            .url("https://api.openai.com/v1/chat/completions")
            .post(body)
            .addHeader("Authorization", "Bearer $apiKey")
            .addHeader("Content-Type", "application/json")
            .build()

        Log.d("ChatFragment", "Sending request: $json")

        lifecycleScope.launch(Dispatchers.IO) {
            try {
                val response = client.newCall(request).execute()
                val responseBody = response.body?.string()
                Log.d("ChatFragment", "Received response: $responseBody")

                when {
                    response.code == 401 -> { // Unauthorized - likely API key issue
                        consecutiveApiKeyErrors++
                        withContext(Dispatchers.Main) {
                            if (consecutiveApiKeyErrors >= MAX_API_KEY_ERRORS_BEFORE_UPDATE) {
                                showApiKeyUpdateRequiredDialog()
                            } else {
                                showCustomToast(getString(R.string.api_key_error))
                            }
                        }
                        return@launch
                    }
                    !response.isSuccessful -> {
                        withContext(Dispatchers.Main) {
                            showCustomToast("Unexpected response from server")
                        }
                        return@launch
                    }
                    else -> {
                        consecutiveApiKeyErrors = 0 // Reset counter on successful response
                        responseBody?.let {
                            try {
                                val jsonResponse = JSONObject(it)
                                val choices = jsonResponse.optJSONArray("choices")

                                if (choices != null && choices.length() > 0) {
                                    val reply = choices.getJSONObject(0).getJSONObject("message").getString("content").trim()
                                    withContext(Dispatchers.Main) {
                                        callback(reply)
                                    }
                                } else {
                                    withContext(Dispatchers.Main) {
                                        showCustomToast("No choices found in the response")
                                    }
                                }
                            } catch (e: JSONException) {
                                Log.e("ChatFragment", "Failed to parse response", e)
                                withContext(Dispatchers.Main) {
                                    showCustomToast("Failed to parse response")
                                }
                            }
                        }
                    }
                }
            } catch (e: IOException) {
                Log.e("ChatFragment", "Failed to get response", e)
                withContext(Dispatchers.Main) {
                    showCustomToast("Failed to get response")
                }
            }
        }
    }

    private fun showApiKeyUpdateRequiredDialog() {
        AlertDialog.Builder(requireContext())
            .setTitle(getString(R.string.api_key_update_required))
            .setMessage(getString(R.string.api_key_update_message))
            .setPositiveButton(getString(R.string.update_button)) { _, _ ->
                openPlayStore()
            }
            .setNegativeButton(getString(R.string.later_button), null)
            .setCancelable(false)
            .show()
    }

    private fun openPlayStore() {
        try {
            startActivity(Intent(Intent.ACTION_VIEW,
                Uri.parse("market://details?id=${requireContext().packageName}")))
        } catch (e: ActivityNotFoundException) {
            startActivity(Intent(Intent.ACTION_VIEW,
                Uri.parse("https://play.google.com/store/apps/details?id=${requireContext().packageName}")))
        }
    }

    fun updateSubscriptionStatus(isAdFree: Boolean, expirationTime: Long) {
        isUserSubscribed = isAdFree
        subscriptionExpirationTime = expirationTime

        if (isAdFree) {
            canSendMessage = true
        } else {
            loadRewardedAd()
        }

        if (expirationTime <= System.currentTimeMillis()) {
            canSendMessage = false
        }
    }

    private fun openDocumentPicker() {
        val intent = Intent(Intent.ACTION_OPEN_DOCUMENT).apply {
            addCategory(Intent.CATEGORY_OPENABLE)
            type = "*/*"
            putExtra(Intent.EXTRA_MIME_TYPES, arrayOf(
                "application/pdf",
                "application/msword",
                "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
            ))
        }
        startActivityForResult(intent, PICK_DOCUMENT_REQUEST_CODE)
    }

    private fun checkDailyMessageLimit(): Boolean {
        val sharedPreferences = requireContext().getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
        val lastResetTime = sharedPreferences.getLong(LAST_RESET_TIME_KEY, 0)
        val currentTime = System.currentTimeMillis()

        if (currentTime - lastResetTime > TimeUnit.HOURS.toMillis(24)) {
            sharedPreferences.edit().putLong(LAST_RESET_TIME_KEY, currentTime)
                .putInt(MESSAGE_COUNT_KEY, 0).apply()
        }

        val messageCount = sharedPreferences.getInt(MESSAGE_COUNT_KEY, 0)
        return messageCount < DAILY_MESSAGE_LIMIT
    }

    private fun incrementMessageCount() {
        val sharedPreferences = requireContext().getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
        val messageCount = sharedPreferences.getInt(MESSAGE_COUNT_KEY, 0)
        sharedPreferences.edit().putInt(MESSAGE_COUNT_KEY, messageCount + 1).apply()
    }

    private fun loadChatHistoryById(chatId: String) {
        val sharedPreferences = requireContext().getSharedPreferences("prefs", Context.MODE_PRIVATE)
        val savedChatsArray = JSONArray(sharedPreferences.getString(chatHistoryKey, "[]"))

        chatMessages.clear()

        for (i in 0 until savedChatsArray.length()) {
            val chatObject = savedChatsArray.getJSONObject(i)
            if (chatObject.getString("id") == chatId) {
                val messagesArray = chatObject.getJSONArray("messages")
                for (j in 0 until messagesArray.length()) {
                    val messageObject = messagesArray.getJSONObject(j)
                    val content = messageObject.getString("content")
                    val isUser = messageObject.getBoolean("isUser")
                    chatMessages.add(
                        ChatMessage(
                            id = messageObject.optString("id", System.currentTimeMillis().toString()), // Use existing ID or generate a new one
                            content = content,
                            isUser = isUser
                        )
                    )
                }
                chatAdapter.notifyDataSetChanged()
                binding.recyclerView.smoothScrollToPosition(chatMessages.size - 1)
                break
            }
        }
    }

    private fun showChatOptionsDialog(chatId: String, chatTitle: String) {
        val options = arrayOf("View Chat", "Delete Chat")
        val builder = AlertDialog.Builder(requireContext())
        builder.setTitle(chatTitle)
        builder.setItems(options) { dialog, which ->
            when (which) {
                0 -> loadChatHistoryById(chatId)
                1 -> showDeleteConfirmationDialog(chatId)
            }
        }
        builder.setNegativeButton("Cancel", null)
        builder.show()
    }

    private fun showDeleteConfirmationDialog(chatId: String) {
        val builder = AlertDialog.Builder(requireContext())
        builder.setTitle("Delete Chat")
        builder.setMessage("Are you sure you want to delete this chat?")
        builder.setPositiveButton("Yes") { dialog, which ->
            deleteChatHistoryById(chatId)
        }
        builder.setNegativeButton("No", null)
        builder.show()
    }

    private fun showDeleteAllConfirmationDialog() {
        val builder = AlertDialog.Builder(requireContext())
        builder.setTitle("Delete All Chats")
        builder.setMessage("Are you sure you want to delete all chat history?")
        builder.setPositiveButton("Yes") { dialog, which ->
            deleteAllChatHistory()
        }
        builder.setNegativeButton("No", null)
        builder.show()
    }

    private fun deleteChatHistoryById(chatId: String) {
        val sharedPreferences = requireContext().getSharedPreferences("prefs", Context.MODE_PRIVATE)
        val savedChatsArray = JSONArray(sharedPreferences.getString(chatHistoryKey, "[]"))
        val updatedChatsArray = JSONArray()

        for (i in 0 until savedChatsArray.length()) {
            val chatObject = savedChatsArray.getJSONObject(i)
            if (chatObject.getString("id") != chatId) {
                updatedChatsArray.put(chatObject)
            }
        }

        sharedPreferences.edit().putString(chatHistoryKey, updatedChatsArray.toString()).apply()
        showCustomToast("Chat deleted successfully")
    }

    private fun deleteAllChatHistory() {
        val sharedPreferences = requireContext().getSharedPreferences("prefs", Context.MODE_PRIVATE)
        sharedPreferences.edit().putString(chatHistoryKey, "[]").apply()
        showCustomToast("All chat history deleted successfully")
    }

    private fun showChatGptOptionsDialog() {
        val dialogView = LayoutInflater.from(requireContext()).inflate(R.layout.dialog_with_overlay, null)
        val dialog = AlertDialog.Builder(requireContext())
            .setView(dialogView)
            .setCancelable(true)
            .create()

        dialog.window?.setBackgroundDrawableResource(android.R.color.transparent)

        // Add emojis, descriptions, and examples for each model
        val options = arrayOf(
            "GPT-3.5 Turbo üöÄ - Fast and cost-effective\nExample: Learn Python basics, write essays, or get quick answers.",
            "GPT-4o üåü - Advanced reasoning and creativity\nExample: Solve complex math problems, write poetry, or brainstorm ideas.",
            "GPT-4o Mini üß© - Lightweight version of GPT-4o\nExample: Quick summaries, simple Q&A, or lightweight tasks.",
            "GPT-4o Search üîç - Web-connected AI\nExample: Get latest news, real-time information, and cited sources.",
            "GPT-4o Mini Search üîç - Lightweight web-connected AI\nExample: Quick web searches with cited results.",
            "O1 üõ†Ô∏è - Optimized for specific tasks\nExample: Code debugging, data analysis, or technical documentation.",
            "O1 Mini üß∞ - Lightweight version of O1\nExample: Simple coding help, quick fixes, or small-scale tasks.",
            "O3 Mini üß† - Reasoning model for complex problem solving\nExample: Advanced coding, scientific reasoning, or multi-step planning.",
            "GPT-4o Realtime Preview ‚è±Ô∏è - Real-time updates and previews\nExample: Live coding assistance, real-time editing, or interactive learning.",
            "GPT-4o Audio Preview üéß - Audio-based interactions\nExample: Learn languages, practice pronunciation, or listen to stories.",
            "GPT-4 Turbo üöÑ - High-speed and high-capacity\nExample: Long-form content creation, deep research, or multitasking.",
            "DALL-E 3 üé® - Generate stunning images\nExample: Create art, design logos, or visualize concepts.",
            "TTS-1 üîä - Text-to-speech with natural voices\nExample: Listen to articles, practice speeches, or create audiobooks.",
            "Gemini üî∑‚ú® - Google's powerful AI model\nExample: Advanced research, creative writing, or coding assistance.",
            "DeepSeek üê¨ - Fast and efficient AI for chat\nExample: Quick answers, challenging math problems, debug complex code, or brainstorm innovative solutions.",
            "GPT-4.1 Mini üñºÔ∏è - Image analysis and understanding\nExample: Analyze images, extract information, or generate descriptions."
        )

        val listView = dialogView.findViewById<ListView>(R.id.optionsListView)
        val adapter = CustomAdapter(requireContext(), android.R.layout.simple_list_item_1, options) // Use the custom adapter
        listView.adapter = adapter

        listView.setOnItemClickListener { _, _, position, _ ->
            if (isUserSubscribed && subscriptionExpirationTime > System.currentTimeMillis()) {
                currentModel = when (position) {
                    0 -> "gpt-3.5-turbo"
                    1 -> "gpt-4o"
                    2 -> "gpt-4o-mini"
                    3 -> "gpt-4o-search-preview"
                    4 -> "gpt-4o-mini-search-preview"
                    5 -> "o1"
                    6 -> "o1-mini"
                    7 -> "o3-mini" // Add the o3-mini model
                    8 -> "gpt-4o-realtime-preview"
                    9 -> "gpt-4o-audio-preview"
                    10 -> "gpt-4-turbo"
                    11 -> "dall-e-3"
                    12 -> "tts-1"
                    13 -> "gemini" // Gemini model
                    14 -> "deepseek" // DeepSeek model
                    15 -> "gpt-4.1-mini" // Add the gpt-4.1-mini model
                    else -> "gpt-3.5-turbo"
                }

                // Enable web search toggle when a search model is selected
                //binding.webSearchToggle.isEnabled = WEB_SEARCH_MODELS.contains(currentModel)
                updateActiveModelButton(options[position].substringBefore(" -")) // Show only the model name in the button
                showCustomToast("Switched to ${options[position].substringBefore(" -")}")
            } else {
                showSubscriptionDialog()
            }
            dialog.dismiss()
        }

        dialog.setOnDismissListener {
            hideOverlay()
        }

        showOverlay()
        dialog.show()
    }

    private fun handleGeminiCompletion(message: String) {
        val geminiApiKey = "AIzaSyBrvfow2rZ8V6nF7GTC64K7RFYI5LQOWqw"
        val geminiUrl = "https://generativelanguage.googleapis.com/v1/models/gemini-pro:generateContent"

        // Correct payload structure for Gemini API
        val contentsArray = JSONArray().apply {
            // Add existing chat history
            for (chatMessage in chatMessages) {
                put(JSONObject().apply {
                    put("role", if (chatMessage.isUser) "user" else "model")
                    put("parts", JSONArray().apply {
                        put(JSONObject().apply {
                            put("text", chatMessage.content)
                        })
                    })
                })
            }

            // Add new user message
            put(JSONObject().apply {
                put("role", "user")
                put("parts", JSONArray().apply {
                    put(JSONObject().apply {
                        put("text", message)
                    })
                })
            })
        }

        val json = JSONObject().apply {
            put("contents", contentsArray)
        }

        val body = json.toString().toRequestBody("application/json; charset=utf-8".toMediaTypeOrNull())
        val request = Request.Builder()
            .url("$geminiUrl?key=$geminiApiKey")
            .post(body)
            .addHeader("Content-Type", "application/json")
            .build()

        Log.d("ChatFragment", "Sending request to Gemini: $json")

        showTypingIndicator()

        lifecycleScope.launch {
            try {
                val response = withContext(Dispatchers.IO) {
                    client.newCall(request).execute()
                }

                val responseBody = response.body?.string()
                Log.d("ChatFragment", "Received response from Gemini: $responseBody")

                if (!response.isSuccessful) {
                    Log.e("ChatFragment", "Unexpected code $response")
                    withContext(Dispatchers.Main) {
                        when (response.code) {
                            400 -> showCustomToast("Bad Request: Check your request parameters")
                            401 -> showCustomToast("Unauthorized: Check your API key")
                            403 -> showCustomToast("Forbidden: You don't have permission to access this resource")
                            500 -> showCustomToast("Server Error: Try again later")
                            else -> showCustomToast("Unexpected response from Gemini API")
                        }
                        removeTypingIndicator()
                    }
                    return@launch
                }

                if (responseBody != null) {
                    try {
                        val jsonResponse = JSONObject(responseBody)
                        Log.d("ChatFragment", "Parsed JSON response from Gemini: $jsonResponse")

                        if (jsonResponse.has("candidates")) {
                            val candidates = jsonResponse.getJSONArray("candidates")
                            if (candidates.length() > 0) {
                                val reply = candidates.getJSONObject(0)
                                    .getJSONObject("content")
                                    .getJSONArray("parts")
                                    .getJSONObject(0)
                                    .getString("text")
                                    .trim()

                                withContext(Dispatchers.Main) {
                                    removeTypingIndicator()
                                    chatMessages.add(
                                        ChatMessage(
                                            id = System.currentTimeMillis().toString(),
                                            content = reply,
                                            isUser = false
                                        )
                                    )
                                    chatAdapter.notifyItemInserted(chatMessages.size - 1)
                                    binding.recyclerView.smoothScrollToPosition(chatMessages.size - 1)
                                    generateFollowUpQuestions(reply)
                                    if (isTtsEnabled) {
                                        handleTextToSpeech(reply)
                                    }
                                    incrementInteractionCount()
                                }
                            } else {
                                withContext(Dispatchers.Main) {
                                    showCustomToast("No candidates found in the response")
                                    removeTypingIndicator()
                                }
                            }
                        } else {
                            withContext(Dispatchers.Main) {
                                showCustomToast("No candidates found in the response")
                                removeTypingIndicator()
                            }
                        }
                    } catch (e: JSONException) {
                        Log.e("ChatFragment", "Failed to parse Gemini response", e)
                        withContext(Dispatchers.Main) {
                            showCustomToast("Failed to parse Gemini response")
                            removeTypingIndicator()
                        }
                    }
                } else {
                    removeTypingIndicator()
                }
            } catch (e: IOException) {
                Log.e("ChatFragment", "Failed to get Gemini response", e)
                withContext(Dispatchers.Main) {
                    showCustomToast("Failed to get Gemini response")
                    removeTypingIndicator()
                }
            }
        }
    }

    private fun handleDeepSeekCompletion(message: String) {
        val deepSeekApiKey = "sk-365290c51f54434e983914c5fae190a8"
        val deepSeekUrl = "https://api.deepseek.com/v1/chat/completions"

        val messagesArray = JSONArray().apply {
            // Add existing chat history
            for (chatMessage in chatMessages) {
                put(JSONObject().apply {
                    put("role", if (chatMessage.isUser) "user" else "assistant")
                    put("content", chatMessage.content)
                })
            }

            // Add new user message
            put(JSONObject().apply {
                put("role", "user")
                put("content", message)
            })
        }

        val json = JSONObject().apply {
            put("model", "deepseek-chat")
            put("messages", messagesArray)
            put("stream", false)
        }

        val body = json.toString().toRequestBody("application/json; charset=utf-8".toMediaTypeOrNull())
        val request = Request.Builder()
            .url(deepSeekUrl)
            .post(body)
            .addHeader("Authorization", "Bearer $deepSeekApiKey")
            .addHeader("Content-Type", "application/json")
            .build()

        Log.d("ChatFragment", "Sending request to DeepSeek: $json")

        showTypingIndicator()

        // Increase timeout duration
        val clientWithTimeout = client.newBuilder()
            .readTimeout(60, TimeUnit.SECONDS)
            .writeTimeout(60, TimeUnit.SECONDS)
            .connectTimeout(60, TimeUnit.SECONDS)
            .build()

        lifecycleScope.launch {
            try {
                val response = withContext(Dispatchers.IO) {
                    clientWithTimeout.newCall(request).execute()
                }

                val responseBody = response.body?.string()
                Log.d("ChatFragment", "Received response from DeepSeek: $responseBody")

                if (!response.isSuccessful) {
                    Log.e("ChatFragment", "Unexpected code $response")
                    withContext(Dispatchers.Main) {
                        when (response.code) {
                            400 -> showCustomToast("Bad Request: Check your request parameters")
                            401 -> showCustomToast("Unauthorized: Check your API key")
                            403 -> showCustomToast("Forbidden: You don't have permission to access this resource")
                            404 -> showCustomToast("Not Found: Check the API URL")
                            500 -> showCustomToast("Server Error: Try again later")
                            else -> showCustomToast("Unexpected response from DeepSeek API: ${response.code}")
                        }
                        removeTypingIndicator()
                    }
                    return@launch
                }

                responseBody?.let {
                    try {
                        val jsonResponse = JSONObject(it)
                        Log.d("ChatFragment", "Parsed JSON response from DeepSeek: $jsonResponse")

                        if (jsonResponse.has("choices")) {
                            val choices = jsonResponse.getJSONArray("choices")
                            if (choices.length() > 0) {
                                val reply = choices.getJSONObject(0).getJSONObject("message")
                                    .getString("content").trim()

                                withContext(Dispatchers.Main) {
                                    removeTypingIndicator()
                                    chatMessages.add(
                                        ChatMessage(
                                            id = System.currentTimeMillis().toString(),
                                            content = reply,
                                            isUser = false
                                        )
                                    )
                                    chatAdapter.notifyItemInserted(chatMessages.size - 1)
                                    binding.recyclerView.smoothScrollToPosition(chatMessages.size - 1)
                                    generateFollowUpQuestions(reply)
                                    if (isTtsEnabled) {
                                        handleTextToSpeech(reply)
                                    }
                                    incrementInteractionCount()
                                }
                            } else {
                                withContext(Dispatchers.Main) {
                                    showCustomToast("No choices found in the response")
                                    removeTypingIndicator()
                                }
                            }
                        } else {
                            withContext(Dispatchers.Main) {
                                showCustomToast("No choices found in the response")
                                removeTypingIndicator()
                            }
                        }
                    } catch (e: JSONException) {
                        Log.e("ChatFragment", "Failed to parse DeepSeek response", e)
                        withContext(Dispatchers.Main) {
                            showCustomToast("Failed to parse DeepSeek response")
                            removeTypingIndicator()
                        }
                    }
                }
            } catch (e: IOException) {
                Log.e("ChatFragment", "Failed to get DeepSeek response", e)
                withContext(Dispatchers.Main) {
                    showCustomToast("Failed to get DeepSeek response")
                    removeTypingIndicator()
                }
            }
        }
    }

    private fun showOverlay() {
        Log.d("ChatFragment", "Showing overlay")
        binding.subscriptionOverlay.visibility = View.VISIBLE
    }

    private fun hideOverlay() {
        Log.d("ChatFragment", "Hiding overlay")
        binding.subscriptionOverlay.visibility = View.GONE
    }

    private fun updateActiveModelButton(modelName: String) {
        binding.activeModelButton.text = modelName
    }


    private fun handleTextToSpeech(text: String) {
        if (isTtsEnabled) {
            val json = JSONObject().apply {
                put("model", "tts-1")
                put("input", text)
                put("voice", selectedVoice) // Use the selected voice
            }

            val body = json.toString().toRequestBody("application/json; charset=utf-8".toMediaTypeOrNull())
            val request = Request.Builder()
                .url("https://api.openai.com/v1/audio/speech")
                .post(body)
                .addHeader("Authorization", "Bearer $apiKey")
                .build()

            client.newCall(request).enqueue(object : Callback {
                override fun onFailure(call: Call, e: IOException) {
                    Log.e("ChatFragment", "Failed to get TTS response", e)
                    requireActivity().runOnUiThread {
                        showCustomToast("Failed to get TTS response")
                    }
                }

                override fun onResponse(call: Call, response: Response) {
                    if (!response.isSuccessful || response.body == null) {
                        Log.e("ChatFragment", "Unexpected code $response")
                        requireActivity().runOnUiThread {
                            showCustomToast("Unexpected response from TTS API")
                        }
                        return
                    }

                    val audioBytes = response.body?.bytes()
                    if (audioBytes != null) {
                        val tempFile = File.createTempFile("tts_audio", ".mp3", requireContext().cacheDir)
                        tempFile.writeBytes(audioBytes)
                        requireActivity().runOnUiThread {
                            playAudioFromFile(tempFile)
                        }
                    } else {
                        requireActivity().runOnUiThread {
                            showCustomToast("Failed to get audio data")
                        }
                    }
                }
            })
        }
    }

    private fun sendImageToOpenAI(bitmap: Bitmap) {
        val base64Image = encodeImageToBase64(bitmap)
        analyzeImage(base64Image)
    }

    private fun resizeBitmap(bitmap: Bitmap, maxWidth: Int, maxHeight: Int): Bitmap {
        val width = bitmap.width
        val height = bitmap.height

        val aspectRatio = width.toFloat() / height.toFloat()
        var newWidth = maxWidth
        var newHeight = maxHeight

        if (width > height) {
            newHeight = (newWidth / aspectRatio).toInt()
        } else {
            newWidth = (newHeight * aspectRatio).toInt()
        }

        return Bitmap.createScaledBitmap(bitmap, newWidth, newHeight, true)
    }

    private fun encodeImageToBase64(bitmap: Bitmap): String {
        val resizedBitmap = resizeBitmap(bitmap, 1024, 1024) // Resize the bitmap to a maximum of 1024x1024
        val byteArrayOutputStream = ByteArrayOutputStream()
        resizedBitmap.compress(Bitmap.CompressFormat.JPEG, 100, byteArrayOutputStream)
        val byteArray = byteArrayOutputStream.toByteArray()
        return Base64.encodeToString(byteArray, Base64.DEFAULT)
    }

    private fun showImageProcessingOptions(bitmap: Bitmap) {
        val options = arrayOf("Extract Text", "Analyze Image")
        val builder = AlertDialog.Builder(requireContext())
        builder.setTitle("Choose an option")
        builder.setItems(options) { dialog, which ->
            when (which) {
                0 -> detectTextFromImage(bitmap)
                1 -> sendImageToOpenAI(bitmap)
            }
        }
        builder.show()
    }
    private fun analyzeImage(base64Image: String) {
        val json = JSONObject().apply {
            put("model", "gpt-4o") // Updated to use GPT-4o
            put("messages", JSONArray().apply {
                put(JSONObject().apply {
                    put("role", "user")
                    put("content", JSONArray().apply {
                        put(JSONObject().apply {
                            put("type", "text")
                            put("text", "What is in this image?")
                        })
                        put(JSONObject().apply {
                            put("type", "image_url")
                            put("image_url", JSONObject().apply {
                                put("url", "data:image/jpeg;base64,$base64Image")
                                // For GPT-4o, detail can be "low", "high", or "auto"
                                put("detail", "auto")
                            })
                        })
                    })
                })
            })
            put("max_tokens", 300)
        }

        val body = json.toString().toRequestBody("application/json; charset=utf-8".toMediaTypeOrNull())
        val request = Request.Builder()
            .url("https://api.openai.com/v1/chat/completions")
            .post(body)
            .addHeader("Authorization", "Bearer $apiKey")
            .addHeader("Content-Type", "application/json")
            .build()

        client.newCall(request).enqueue(object : Callback {
            override fun onFailure(call: Call, e: IOException) {
                Log.e("ChatFragment", "API call failed", e)
                requireActivity().runOnUiThread {
                    showCustomToast("Network error: ${e.message}")
                }
            }

            override fun onResponse(call: Call, response: Response) {
                if (!response.isSuccessful) {
                    val errorBody = response.body?.string() ?: "No error details"
                    Log.e("ChatFragment", "API Error ${response.code}: $errorBody")
                    requireActivity().runOnUiThread {
                        showCustomToast("API Error: ${parseErrorMessage(errorBody)}")
                    }
                    return
                }

                response.body?.use { responseBody ->
                    try {
                        val jsonResponse = JSONObject(responseBody.string())
                        val reply = jsonResponse.getJSONArray("choices")
                            .getJSONObject(0)
                            .getJSONObject("message")
                            .getString("content")
                            .trim()

                        requireActivity().runOnUiThread {
                            addMessageToChat(reply, false)
                        }
                    } catch (e: Exception) {
                        Log.e("ChatFragment", "Response parsing failed", e)
                        requireActivity().runOnUiThread {
                            showCustomToast("Failed to parse response")
                        }
                    }
                }
            }
        })
    }

    private fun parseErrorMessage(errorBody: String): String {
        return try {
            JSONObject(errorBody).getJSONObject("error").getString("message")
        } catch (e: Exception) {
            "Unknown error (code: ${errorBody.take(200)})"
        }
    }
    private fun checkDailyLimit(model: String, limit: Int): Boolean {
        val sharedPreferences = requireContext().getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
        val lastResetTimeKey = "${model}_last_reset_time"
        val usageCountKey = "${model}_usage_count"
        val lastResetTime = sharedPreferences.getLong(lastResetTimeKey, 0)
        val currentTime = System.currentTimeMillis()

        if (currentTime - lastResetTime > TimeUnit.HOURS.toMillis(24)) {
            sharedPreferences.edit().putLong(lastResetTimeKey, currentTime)
                .putInt(usageCountKey, 0).apply()
        }

        val usageCount = sharedPreferences.getInt(usageCountKey, 0)
        return usageCount < limit
    }

    private fun incrementModelUsage(model: String) {
        val sharedPreferences = requireContext().getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
        val usageCountKey = "${model}_usage_count"
        val usageCount = sharedPreferences.getInt(usageCountKey, 0)
        sharedPreferences.edit().putInt(usageCountKey, usageCount + 1).apply()
    }


    private fun copyHighlightedText() {
        val start = binding.messageEditText.selectionStart
        val end = binding.messageEditText.selectionEnd
        val selectedText = binding.messageEditText.text.substring(start, end)

        val clipboard = requireContext().getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager
        val clip = ClipData.newPlainText("Copied Text", selectedText)
        clipboard.setPrimaryClip(clip)

        showCustomToast("Text copied to clipboard")
    }

    private fun deleteHighlightedText() {
        val start = binding.messageEditText.selectionStart
        val end = binding.messageEditText.selectionEnd
        binding.messageEditText.text.delete(start, end)
        showCustomToast("Text deleted")
    }
    private fun initializeSpeechRecognizer() {
        if (SpeechRecognizer.isRecognitionAvailable(requireContext())) {
            speechRecognizer = SpeechRecognizer.createSpeechRecognizer(requireContext())
            speechRecognizer?.setRecognitionListener(object : RecognitionListener {
                override fun onReadyForSpeech(params: Bundle?) {
                    showCustomToast("Listening...")
                }

                override fun onBeginningOfSpeech() {
                    binding.voiceInputButton.text = "üõë"
                }

                override fun onRmsChanged(rmsdB: Float) {}

                override fun onBufferReceived(buffer: ByteArray?) {}

                override fun onEndOfSpeech() {
                    binding.voiceInputButton.text = "üé§"
                }

                override fun onError(error: Int) {
                    showCustomToast("Error: $error")
                    binding.voiceInputButton.text = "üé§"
                }

                override fun onResults(results: Bundle?) {
                    val matches = results?.getStringArrayList(SpeechRecognizer.RESULTS_RECOGNITION)
                    if (!matches.isNullOrEmpty()) {
                        binding.messageEditText.setText(matches[0])
                        binding.messageEditText.setSelection(matches[0].length)
                    }
                }

                override fun onPartialResults(partialResults: Bundle?) {}

                override fun onEvent(eventType: Int, params: Bundle?) {}
            })
        } else {
            showCustomToast("Speech recognition is not available on this device.")
        }
    }
    private fun startVoiceRecognition() {
        val intent = Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH).apply {
            putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL, RecognizerIntent.LANGUAGE_MODEL_FREE_FORM)
            putExtra(RecognizerIntent.EXTRA_LANGUAGE, Locale.getDefault())
            putExtra(RecognizerIntent.EXTRA_PROMPT, "Speak now...")
        }
        try {
            startActivityForResult(intent, REQUEST_CODE_SPEECH_INPUT)
        } catch (e: ActivityNotFoundException) {
            showCustomToast("Speech recognition not supported on this device")
        }
    }


    private fun checkAndRequestPermissions(): Boolean {
        val requiredPermissions = mutableListOf<String>().apply {
            add(Manifest.permission.RECORD_AUDIO)
            if (Build.VERSION.SDK_INT >= 33) {
                add(Manifest.permission.READ_MEDIA_IMAGES) // Android 13+
            } else {
                add(Manifest.permission.READ_EXTERNAL_STORAGE)
            }
        }

        return if (requiredPermissions.any {
                ContextCompat.checkSelfPermission(requireContext(), it) != PackageManager.PERMISSION_GRANTED
            }) {
            requestPermissions(
                requiredPermissions.toTypedArray(),
                PERMISSION_REQUEST_CODE
            )
            false
        } else {
            true
        }
    }


    private fun startImageCrop(uri: Uri) {
        val cropIntent = CropImage.activity(uri)
            .setGuidelines(CropImageView.Guidelines.ON)
            .getIntent(requireContext())
        cropImageLauncher.launch(cropIntent)
    }

    /*override fun onRequestPermissionsResult(requestCode: Int, permissions: Array<out String>, grantResults: IntArray) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults)
        when (requestCode) {
            WRITE_EXTERNAL_STORAGE_PERMISSION_REQUEST_CODE -> {
                if ((grantResults.isNotEmpty() && grantResults[0] == PackageManager.PERMISSION_GRANTED)) {
                    val imageUrl = binding.imageContainer.getTag(R.id.image_url) as? String
                    if (imageUrl != null) {
                        downloadImage(imageUrl)
                    }
                } else {
                    showCustomToast("Storage permission is required to download the image")
                }
            }
        }
    }*/

    /*override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
        super.onActivityResult(requestCode, requestCode, data)
        if (requestCode == REQUEST_IMAGE_CAPTURE && resultCode == Activity.RESULT_OK) {
            val imageBitmap = data?.extras?.get("data") as Bitmap
            detectTextFromImage(imageBitmap)
        } else if (requestCode == REQUEST_CODE_SPEECH_INPUT && resultCode == Activity.RESULT_OK) {
            val result = data?.getStringArrayListExtra(RecognizerIntent.EXTRA_RESULTS)
            result?.let {
                binding.messageEditText.setText(it[0])
            }
        } else if (requestCode == PICK_DOCUMENT_REQUEST_CODE && resultCode == Activity.RESULT_OK) {
            data?.data?.let { uri ->
                handleDocUpload(uri)
            }
        }
    }*/
    /*private fun loadInterstitialAd() {
        val adRequest = AdRequest.Builder().build()
        InterstitialAd.load(
            requireContext(),
            "ca-app-pub-9180832030816304/7454777206",
            adRequest,
            object : InterstitialAdLoadCallback() {
                override fun onAdFailedToLoad(adError: LoadAdError) {
                    Log.d("ChatFragment", "Interstitial ad failed to load: ${adError.message}")
                    interstitialAd = null
                    isInterstitialAdLoaded = false
                }

                override fun onAdLoaded(ad: InterstitialAd) {
                    Log.d("ChatFragment", "Interstitial ad loaded.")
                    interstitialAd = ad
                    isInterstitialAdLoaded = true
                }
            }
        )
    }

    private fun showInterstitialAd() {
        if (isUserSubscribed) {
            Log.d("ChatFragment", "User is subscribed, not showing interstitial ad.")
            return
        }

        if (isInterstitialAdLoaded && interstitialAd != null) {
            interstitialAd?.show(requireActivity())
        } else {
            Log.d("ChatFragment", "Interstitial ad is not ready yet.")
            loadInterstitialAd()
        }
    }*/

    /*private fun stopVoiceRecognition() {
        speechRecognizer?.stopListening()
        showRecordingStatus(false)
        binding.voiceInputButton.text = "üé§"
    }*/

    private fun showReportDialog() {
        val dialogView = LayoutInflater.from(requireContext()).inflate(R.layout.dialog_report, null)
        val reportDescription = dialogView.findViewById<EditText>(R.id.reportDescription)

        AlertDialog.Builder(requireContext())
            .setView(dialogView)
            .setTitle("Report Content")
            .setPositiveButton("Submit") { dialog, which ->
                val description = reportDescription.text.toString()
                submitReport(description)
            }
            .setNegativeButton("Cancel", null)
            .show()
    }

    private fun submitReport(description: String) {
        val emailIntent = Intent(Intent.ACTION_SEND).apply {
            type = "message/rfc822"
            putExtra(Intent.EXTRA_EMAIL, arrayOf("nsbusiso542@gmail.com")) // Replace with your support email address
            putExtra(Intent.EXTRA_SUBJECT, "User Report")
            putExtra(Intent.EXTRA_TEXT, description)
        }

        try {
            startActivity(Intent.createChooser(emailIntent, "Send report via email..."))
        } catch (ex: android.content.ActivityNotFoundException) {
            Toast.makeText(requireContext(), "No email clients installed.", Toast.LENGTH_SHORT).show()
        }
    }

    private fun toggleFollowUpQuestions() {
        if (isFollowUpQuestionsExpanded) {
            followUpQuestionsScrollView.visibility = View.GONE
            expandFollowUpQuestionsButton.text = "‚ñº"
        } else {
            followUpQuestionsScrollView.visibility = View.VISIBLE
            expandFollowUpQuestionsButton.text = "‚ñ≤"
        }
        isFollowUpQuestionsExpanded = !isFollowUpQuestionsExpanded
    }

    private fun startNewConversation() {
        chatMessages.clear()
        chatAdapter.notifyDataSetChanged()
        conversationId = generateConversationId()
        sendGreetingMessage()
        showCustomToast("New conversation started")
    }

    private fun showHelpDialog() {
        // Inflate the custom layout
        val dialogView = LayoutInflater.from(requireContext()).inflate(R.layout.dialog_help, null)

        // Set the title and message
        val title = dialogView.findViewById<TextView>(R.id.title)
        val message = dialogView.findViewById<TextView>(R.id.message)

        // Add emojis and format the message
        val helpMessage = """
        **How to Use the Chat** üìö
        
        - **Send Button** ‚úâÔ∏è: Send your message to the AI.
        - **Voice Input** üé§: Use your voice to input text.
        - **Scan Text** üì∑: Scan text from an image or document.
        - **Share Button** üì§: Share the last response from the AI.
        - **Follow-Up Questions** üîÑ: Get suggested follow-up questions based on the AI's response.
        
        **GPT Models** ü§ñ
        
        - **GPT-3.5 Turbo** ‚ö°: Fast and efficient for most tasks.
        - **GPT-4o** üß†: Advanced model for more complex queries.
        - **DALL-E 3** üé®: Generate images from text prompts.
        - **TTS-1** üîä: Convert text to speech.
    """.trimIndent()

        // Set the message text
        message.text = helpMessage
        AlertDialog.Builder(requireContext(), R.style.CustomDialogTheme)
            .setView(dialogView)
            .setPositiveButton("Got it! üëç", null)
            .show()
    }

    fun setQuestionText(question: String) {
        binding.messageEditText.apply {
            setText(question)
            setSelection(question.length) // Move cursor to end
            requestFocus()

            // Show keyboard
            val imm = context.getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager
            imm.showSoftInput(this, InputMethodManager.SHOW_IMPLICIT)
        }
    }

    private fun updateSelectedVoice(voice: String) {
        selectedVoice = voice
        saveSelectedVoice(voice)
        binding.voiceSelectionButton.text = "üéôÔ∏è ${voice.replaceFirstChar { it.uppercase() }}"
    }



    private fun updateTtsButtonState() {
        binding.ttsToggleButton.apply {
            // For ToggleButton, use setBackgroundTintList
            backgroundTintList = ColorStateList.valueOf(
                ContextCompat.getColor(
                    context,
                    if (isTtsEnabled) R.color.greenn else R.color.card_surface
                )
            )

            // ToggleButton handles text automatically
            isChecked = isTtsEnabled
        }
    }

    private fun hideKeyboard() {
        val imm = requireActivity().getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager
        val currentFocus = requireActivity().currentFocus
        if (currentFocus is EditText) {
            imm.hideSoftInputFromWindow(currentFocus.windowToken, 0)
            currentFocus.clearFocus()
        } else {
            imm.hideSoftInputFromWindow(view?.windowToken, 0)
        }
    }

    override fun onInit(status: Int) {
        if (status == TextToSpeech.SUCCESS) {
            val result = tts?.setLanguage(Locale.US)
            if (result == TextToSpeech.LANG_MISSING_DATA || result == TextToSpeech.LANG_NOT_SUPPORTED) {
                Log.e("ChatFragment", "Language not supported")
                showCustomToast("TTS language not supported")
            } else {
                Log.d("ChatFragment", "TTS initialized successfully")
            }
        } else {
            Log.e("ChatFragment", "TTS initialization failed")
            showCustomToast("TTS initialization failed")
        }
    }

    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
        tts?.stop()
        tts?.shutdown()
    }

    private fun initializeChat(model: String?, conversationId: String?) {
        if (model != null && conversationId != null) {
            // Initialize the chat with the provided model and conversation ID
        }
    }


    fun setEmailContent(emailContent: String) {
        // Set the email content to the message input box
        binding.messageEditText.setText(emailContent)

        // Optionally move cursor to end
        binding.messageEditText.setSelection(emailContent.length)
    }

    fun setExtractedText(text: String) {
        binding.messageEditText.setText(text)
        binding.messageEditText.setSelection(text.length) // Ensure cursor is at end
        binding.messageEditText.requestFocus() // Optional: bring focus to the input field
    }
    fun setRecognizedText(text: String) {
        view?.findViewById<EditText>(R.id.messageEditText)?.apply {
            setText(text)
            setSelection(text.length) // Move cursor to end
        }
    }

    private fun detectTextFromImage(bitmap: Bitmap) {
        // Show loading indicator
        binding.progressBar.visibility = View.VISIBLE

        // Process image directly using ML Kit
        val recognizer = TextRecognition.getClient(TextRecognizerOptions.DEFAULT_OPTIONS)
        val image = InputImage.fromBitmap(bitmap, 0)

        recognizer.process(image)
            .addOnSuccessListener { visionText ->
                // Process the recognized text
                val extractedText = processVisionText(visionText)

                // Populate directly into input box
                requireActivity().runOnUiThread {
                    binding.messageEditText.setText(extractedText)
                    binding.messageEditText.setSelection(extractedText.length)
                    binding.progressBar.visibility = View.GONE
                    showCustomToast("Text extracted successfully!")
                }
            }
            .addOnFailureListener { e ->
                requireActivity().runOnUiThread {
                    binding.progressBar.visibility = View.GONE
                    showCustomToast("Text recognition failed: ${e.message}")
                    Log.e("ChatFragment", "Text recognition error", e)
                }
            }
    }

    private fun processVisionText(visionText: Text): String {
        val stringBuilder = StringBuilder()

        // Process all text blocks
        for (block in visionText.textBlocks) {
            stringBuilder.append(block.text)
            stringBuilder.append("\n") // Add newline between blocks
        }

        return stringBuilder.toString().trim()
    }
    private fun processTextBlock(result: Text) {
        val resultText = result.text
        Log.d("ChatFragment", "Detected Text: $resultText")

        if (resultText.isNotEmpty()) {
            requireActivity().runOnUiThread {
                binding.messageEditText.setText(resultText)
            }
        } else {
            requireActivity().runOnUiThread {
                showCustomToast("No text detected.")
            }
        }

        for (block in result.textBlocks) {
            val blockText = block.text
            val blockCornerPoints = block.cornerPoints
            val blockFrame = block.boundingBox
            Log.d("ChatFragment", "Block Text: $blockText")
            Log.d("ChatFragment", "Block BoundingBox: $blockFrame")
            Log.d("ChatFragment", "Block Corner Points: ${blockCornerPoints?.joinToString()}")

            for (line in block.lines) {
                val lineText = line.text
                val lineCornerPoints = line.cornerPoints
                val lineFrame = line.boundingBox
                Log.d("ChatFragment", "Line Text: $lineText")
                Log.d("ChatFragment", "Line BoundingBox: $lineFrame")
                Log.d("ChatFragment", "Line Corner Points: ${lineCornerPoints?.joinToString()}")

                for (element in line.elements) {
                    val elementText = element.text
                    val elementCornerPoints = element.cornerPoints
                    val elementFrame = element.boundingBox
                    Log.d("ChatFragment", "Element Text: $elementText")
                    Log.d("ChatFragment", "Element BoundingBox: $elementFrame")
                    Log.d("ChatFragment", "Element Corner Points: ${elementCornerPoints?.joinToString()}")
                }
            }
        }
    }

    private fun processSelectedFile(uri: Uri) {
        val mimeType = requireContext().contentResolver.getType(uri)

        val callback = object : FileUtils.TextExtractionCallback {
            override fun onTextExtracted(extractedText: String) {
                requireActivity().runOnUiThread {
                    binding.messageEditText.setText(extractedText)
                    binding.messageEditText.setSelection(extractedText.length)
                    showCustomToast("Text extracted successfully!")
                }
            }

            override fun onError(errorMessage: String) {
                requireActivity().runOnUiThread {
                    showCustomToast(errorMessage)
                }
            }
        }

        when {
            mimeType?.startsWith("image/") == true -> {
                FileUtils.extractTextFromImage(requireContext(), uri, callback)
            }
            mimeType in setOf(
                "application/pdf",
                "application/msword",
                "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
                "application/vnd.ms-excel",
                "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
            ) -> {
                FileUtils.extractTextFromDocument(requireContext(), uri, callback)
            }
            else -> {
                showCustomToast("Unsupported file type")
            }
        }
    }
    private fun showImageOrDocumentPickerDialog() {
        val options = arrayOf("Capture Image", "Pick Image", "Pick Document")
        val builder = AlertDialog.Builder(requireContext())
        builder.setTitle("Choose an option")
        builder.setItems(options) { dialog, which ->
            when (which) {
                0 -> checkCameraPermission()
                1 -> openImagePicker()
                2 -> openDocumentPicker()
            }
        }
        builder.show()
    }


    private fun openImagePicker() {
        val intent = Intent(Intent.ACTION_GET_CONTENT).apply {
            type = "image/*"
            addCategory(Intent.CATEGORY_OPENABLE)
        }
        startActivityForResult(intent, PICK_IMAGE_REQUEST_CODE)
    }


    private fun handleDocUpload(uri: Uri) {
        FileUtils.extractTextFromDocument(requireContext(), uri, object : FileUtils.TextExtractionCallback {
            override fun onTextExtracted(extractedText: String) {
                requireActivity().runOnUiThread {
                    binding.messageEditText.setText(extractedText)
                    binding.messageEditText.setSelection(extractedText.length)
                    showCustomToast("Text extracted successfully!")
                }
            }

            override fun onError(errorMessage: String) {
                requireActivity().runOnUiThread {
                    showCustomToast(errorMessage)
                }
            }
        })
    }
    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
        super.onActivityResult(requestCode, resultCode, data)

        when (requestCode) {
            PICK_IMAGE_REQUEST_CODE -> {
                if (resultCode == Activity.RESULT_OK) {
                    data?.data?.let { uri ->
                        processSelectedFile(uri)
                    }
                }
            }
            PICK_DOCUMENT_REQUEST_CODE -> {
                if (resultCode == Activity.RESULT_OK) {
                    data?.data?.let { uri ->
                        processSelectedFile(uri)
                    }
                }
            }
            REQUEST_CODE_SPEECH_INPUT -> {
                if (resultCode == Activity.RESULT_OK && data != null) {
                    val result = data.getStringArrayListExtra(RecognizerIntent.EXTRA_RESULTS)
                    result?.let {
                        binding.messageEditText.setText(it[0])
                        binding.messageEditText.setSelection(it[0].length)
                    }
                }
            }


            // Other request codes...


        }
    }
    private fun incrementInteractionCount() {
        val sharedPreferences = requireContext().getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
        val interactionCount = sharedPreferences.getInt(INTERACTION_COUNT_KEY, 0) + 1
        sharedPreferences.edit().putInt(INTERACTION_COUNT_KEY, interactionCount).apply()

        val ratingReminderCount = sharedPreferences.getInt(RATING_REMINDER_COUNT_KEY, 0)

        if (interactionCount == 2 || interactionCount == 10) {
            showRatingDialog()
            sharedPreferences.edit().putInt(RATING_REMINDER_COUNT_KEY, ratingReminderCount + 1).apply()
        }
    }

    private fun showSubscriptionDialog() {
        val dialogView = LayoutInflater.from(requireContext()).inflate(R.layout.dialog_subscription_app, null)
        val title: TextView = dialogView.findViewById(R.id.title)
        val message: TextView = dialogView.findViewById(R.id.message)
        val lottieAnimationView: LottieAnimationView = dialogView.findViewById(R.id.lottieAnimationView)

        title.text = "Buy Now! üéâ"
        message.text = Html.fromHtml(
            "<font color='#008000'><b>Enjoy unlimited chat</b></font>.<br><br>" +
                    "Unlock all features and enjoy an ad-free experience. üõí<br><br>" +
                    "Create your own EBook, your own APP with personalized features, generate stunning pictures, wallpapers, icons from simple text. ‚ú®<br><br>" +
                    "<b>Learn anything</b> with our powerful models, from <b>maths</b> and <b>science</b> to <b>coding</b>. üìöüí°<br><br>" +
                    "Buy now and get access to all these premium features and more! üöÄ"
        )

        val dialog = AlertDialog.Builder(requireContext())
            .setView(dialogView)
            .setPositiveButton("Buy") { dialog, which ->
                subscriptionClickListener?.onSubscriptionClick()
            }
            .setNegativeButton("Cancel", null)
            .create()

        dialog.setOnShowListener {
            val positiveButton = dialog.getButton(AlertDialog.BUTTON_POSITIVE)
            val negativeButton = dialog.getButton(AlertDialog.BUTTON_NEGATIVE)

            // Customize the buttons
            positiveButton.setTextColor(Color.WHITE)
            positiveButton.setBackgroundColor(Color.parseColor("#FF9800")) // Solid orange color
            negativeButton.setTextColor(Color.BLACK)
            negativeButton.setBackgroundColor(Color.LTGRAY)

            // Set layout parameters with weight
            val layoutParams = LinearLayout.LayoutParams(
                0, // Width set to 0dp to use weight
                LinearLayout.LayoutParams.WRAP_CONTENT
            ).apply {
                weight = 1f // Equal weight distribution
                setMargins(16, 8, 16, 8)
            }

            positiveButton.layoutParams = layoutParams
            negativeButton.layoutParams = layoutParams

            // Set parent background
            val parent = positiveButton.parent as View
            parent.setBackgroundColor(Color.WHITE)

            // Animation (unchanged)
            val animator = ObjectAnimator.ofFloat(positiveButton, "translationY", 0f, 10f, 0f)
            animator.duration = 1000
            animator.repeatCount = ObjectAnimator.INFINITE
            animator.start()
        }

        dialog.show()
    }

    private fun showRatingDialog() {
        val dialogView = LayoutInflater.from(requireContext()).inflate(R.layout.dialog_rate_app, null)
        val title = dialogView.findViewById<TextView>(R.id.title)
        val message = dialogView.findViewById<TextView>(R.id.message)

        title.text = "Rate AITeacher! ‚≠ê"
        message.text = "We hope you are enjoying AITeacher. Please take a moment to rate the app on the Google Play Store. üôè"

        val dialog = AlertDialog.Builder(requireContext())
            .setView(dialogView)
            .setPositiveButton("Rate") { dialog, which ->
                // Direct the user to the Google Play Store to leave a review
                val appPackageName = requireContext().packageName
                try {
                    startActivity(Intent(Intent.ACTION_VIEW, Uri.parse("market://details?id=$appPackageName")))
                } catch (e: android.content.ActivityNotFoundException) {
                    startActivity(Intent(Intent.ACTION_VIEW, Uri.parse("https://play.google.com/store/apps/details?id=$appPackageName")))
                }
            }
            .setNegativeButton("Cancel", null)
            .create()

        dialog.setOnShowListener {
            val positiveButton = dialog.getButton(AlertDialog.BUTTON_POSITIVE)
            val negativeButton = dialog.getButton(AlertDialog.BUTTON_NEGATIVE)

            // Customize the buttons
            positiveButton.setTextColor(Color.BLACK)
            positiveButton.setBackgroundColor(Color.WHITE)
            negativeButton.setTextColor(Color.BLACK)
            negativeButton.setBackgroundColor(Color.WHITE)

            // Set the layout parameters for the buttons
            val layoutParams = LinearLayout.LayoutParams(
                LinearLayout.LayoutParams.WRAP_CONTENT,
                LinearLayout.LayoutParams.WRAP_CONTENT
            )
            layoutParams.setMargins(8, 0, 8, 0)
            positiveButton.layoutParams = layoutParams
            negativeButton.layoutParams = layoutParams

            // Set the background color of the button bar
            val parent = positiveButton.parent as View
            parent.setBackgroundColor(Color.WHITE)
        }

        dialog.show()
    }

    private fun showVoiceSelectionDialog() {
        val voices = arrayOf("Alloy", "Echo", "Fable", "Onyx", "Nova", "Shimmer")
        val builder = AlertDialog.Builder(requireContext())
        builder.setTitle("Select TTS Voice")
        builder.setItems(voices) { dialog, which ->
            val selectedVoice = voices[which].lowercase(Locale.ROOT)
            updateSelectedVoice(selectedVoice)
            showCustomToast("Selected voice: ${voices[which]}")
        }
        builder.setNegativeButton("Cancel", null)
        builder.show()
    }

    private var selectedVoice = "alloy" // Default voice

    private val SELECTED_VOICE_KEY = "selected_voice"

    private fun saveSelectedVoice(voice: String) {
        val sharedPreferences = requireContext().getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
        sharedPreferences.edit().putString(SELECTED_VOICE_KEY, voice).apply()
    }

    private fun loadSelectedVoice(): String {
        val sharedPreferences = requireContext().getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
        return sharedPreferences.getString(SELECTED_VOICE_KEY, "alloy") ?: "alloy"
    }

    private fun loadConversationFromJson(conversationJson: String) {
        try {
            val messagesArray = JSONArray(conversationJson)
            for (i in 0 until messagesArray.length()) {
                val messageObject = messagesArray.getJSONObject(i)
                val content = messageObject.getString("content")
                val isUser = messageObject.getBoolean("isUser")
                chatMessages.add(
                    ChatMessage(
                        id = System.currentTimeMillis().toString(), // Generate a unique ID
                        content = content,
                        isUser = isUser
                    )
                )
            }
            chatAdapter.notifyDataSetChanged()
            binding.recyclerView.smoothScrollToPosition(chatMessages.size - 1)
        } catch (e: JSONException) {
            Log.e("ChatFragment", "Failed to parse conversation JSON", e)
            showCustomToast("Failed to load conversation")
        }
    }

    private fun generateConversationId(): String {
        val timestamp = System.currentTimeMillis()
        val date = Date(timestamp)
        val dateFormat = java.text.SimpleDateFormat("yyyy-MM-dd_HH:mm:ss", Locale.getDefault())
        return "conversation_${dateFormat.format(date)}"
    }

    private fun sendGreetingMessage() {
        // Randomly select a greeting from the list
        val randomGreeting = greetings.random()
        addMessageToChat(randomGreeting, false)
    }

    private fun saveChatHistory() {
        val sharedPreferences = requireContext().getSharedPreferences("prefs", Context.MODE_PRIVATE)
        val editor = sharedPreferences.edit()
        val messagesArray = JSONArray()
        for (chatMessage in chatMessages) {
            val messageObject = JSONObject().apply {
                put("content", chatMessage.content)
                put("isUser", chatMessage.isUser)
            }
            messagesArray.put(messageObject)
        }

        val chatTitle = "Chat with $currentModel on ${java.text.SimpleDateFormat("yyyy-MM-dd HH:mm:ss", Locale.getDefault()).format(Date())}"
        val chatObject = JSONObject().apply {
            put("id", conversationId ?: generateConversationId())
            put("title", chatTitle)
            put("messages", messagesArray)
        }

        val savedChatsArray = JSONArray(sharedPreferences.getString(chatHistoryKey, "[]"))
        val updatedChatsArray = JSONArray()

        for (i in 0 until savedChatsArray.length()) {
            val chat = savedChatsArray.getJSONObject(i)
            if (chat.optString("id") != conversationId) {
                updatedChatsArray.put(chat)
            }
        }

        updatedChatsArray.put(chatObject)
        editor.putString(chatHistoryKey, updatedChatsArray.toString())
        editor.apply()
    }

    private fun loadChatHistory() {
        val sharedPreferences = requireContext().getSharedPreferences("prefs", Context.MODE_PRIVATE)
        val savedChatsArray = JSONArray(sharedPreferences.getString(chatHistoryKey, "[]"))

        for (i in 0 until savedChatsArray.length()) {
            val chatObject = savedChatsArray.getJSONObject(i)
            if (chatObject.optString("id") == conversationId) {
                val messagesArray = chatObject.getJSONArray("messages")
                for (j in 0 until messagesArray.length()) {
                    val messageObject = messagesArray.getJSONObject(j)
                    val content = messageObject.getString("content")
                    val isUser = messageObject.getBoolean("isUser")
                    chatMessages.add(
                        ChatMessage(
                            id = messageObject.optString("id", System.currentTimeMillis().toString()), // Use existing ID or generate a new one
                            content = content,
                            isUser = isUser
                        )
                    )
                }
                chatAdapter.notifyDataSetChanged()
                binding.recyclerView.smoothScrollToPosition(chatMessages.size - 1)
                break
            }
        }
    }

    private fun showChatHistoryDialog() {
        val sharedPreferences = requireContext().getSharedPreferences("prefs", Context.MODE_PRIVATE)
        val savedChatsArray = JSONArray(sharedPreferences.getString(chatHistoryKey, "[]"))

        val chatTitles = mutableListOf<String>()
        val chatIds = mutableListOf<String>()

        for (i in 0 until savedChatsArray.length()) {
            val chatObject = savedChatsArray.getJSONObject(i)
            chatTitles.add(chatObject.getString("title"))
            chatIds.add(chatObject.getString("id"))
        }

        val builder = AlertDialog.Builder(requireContext())
        builder.setTitle("Chat History")
        builder.setItems(chatTitles.toTypedArray()) { dialog, which ->
            showChatOptionsDialog(chatIds[which], chatTitles[which])
        }
        builder.setNegativeButton("Cancel", null)
        builder.setNeutralButton("Delete All") { dialog, which ->
            showDeleteAllConfirmationDialog()
        }
        builder.show()
    }

    private fun checkCameraPermission() {
        val permissions = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            arrayOf(Manifest.permission.CAMERA, Manifest.permission.READ_MEDIA_IMAGES)
        } else {
            arrayOf(Manifest.permission.CAMERA, Manifest.permission.READ_EXTERNAL_STORAGE)
        }

        if (permissions.any {
                ContextCompat.checkSelfPermission(requireContext(), it) != PackageManager.PERMISSION_GRANTED
            }) {
            requestPermissions(permissions, CAMERA_REQUEST_CODE)
        } else {
            dispatchTakePictureIntent()
        }
    }

    override fun onRequestPermissionsResult(
        requestCode: Int,
        permissions: Array<out String>,
        grantResults: IntArray
    ) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults)

        when (requestCode) {
            CAMERA_REQUEST_CODE -> {
                if (grantResults.all { it == PackageManager.PERMISSION_GRANTED }) {
                    dispatchTakePictureIntent()
                } else {
                    showCustomToast("Camera permission required")
                }
            }

            REQUEST_STORAGE_PERMISSION -> {
                if (grantResults.isNotEmpty() && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                    // Handle storage permission granted
                } else {
                    showCustomToast("Storage permission required")
                }
            }
            PERMISSION_REQUEST_CODE -> {
                if (grantResults.isNotEmpty() && grantResults.all { it == PackageManager.PERMISSION_GRANTED }) {
                    // Permissions granted, proceed with voice recognition
                    startVoiceRecognition()
                } else {
                    showCustomToast("Permissions required for voice recognition")
                }
            }

            // Add other permission request codes here as needed
        }
    }
    private fun checkAndRequestPermissions(permissions: Array<String>, requestCode: Int) {
        val permissionsToRequest = permissions.filter {
            ContextCompat.checkSelfPermission(requireContext(), it) != PackageManager.PERMISSION_GRANTED
        }.toTypedArray()

        if (permissionsToRequest.isNotEmpty()) {
            requestPermissions(permissionsToRequest, requestCode)
        } else {
            onPermissionsGranted(requestCode)
        }
    }

    private fun onPermissionsGranted(requestCode: Int) {
        when (requestCode) {
            CAMERA_REQUEST_CODE -> dispatchTakePictureIntent()
            WRITE_EXTERNAL_STORAGE_PERMISSION_REQUEST_CODE -> {
                val imageUrl = binding.imageContainer.getTag(R.id.image_url) as? String
                if (imageUrl != null) {
                    downloadImage(imageUrl)
                }
            }
            PICK_DOCUMENT_REQUEST_CODE -> openDocumentPicker()
        }
    }

    private fun dispatchTakePictureIntent() {
        val takePictureIntent = Intent(MediaStore.ACTION_IMAGE_CAPTURE)

        // Create a file to save the image
        val photoFile = createImageFile()
        photoFile?.let { file ->
            val photoURI = FileProvider.getUriForFile(
                requireContext(),
                "${requireContext().packageName}.fileprovider",
                file
            )
            takePictureIntent.putExtra(MediaStore.EXTRA_OUTPUT, photoURI)

            // Save the file path to use it later
            currentPhotoPath = file.absolutePath

            captureImageLauncher.launch(takePictureIntent)
        } ?: run {
            showCustomToast("Error creating image file")
        }
    }

    private var currentPhotoPath: String = ""

    @Throws(IOException::class)
    private fun createImageFile(): File? {
        // Create an image file name
        val timeStamp = SimpleDateFormat("yyyyMMdd_HHmmss", Locale.getDefault()).format(Date())
        val storageDir = requireContext().getExternalFilesDir(Environment.DIRECTORY_PICTURES)
        return File.createTempFile(
            "JPEG_${timeStamp}_", /* prefix */
            ".jpg", /* suffix */
            storageDir /* directory */
        ).apply {
            // Save a file: path for use with ACTION_VIEW intents
            currentPhotoPath = absolutePath
        }
    }

    private fun galleryAddPic(imagePath: String) {
        val mediaScanIntent = Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE)
        val f = File(imagePath)
        val contentUri = Uri.fromFile(f)
        mediaScanIntent.data = contentUri
        requireContext().sendBroadcast(mediaScanIntent)
        showCustomToast("Image saved to gallery")
    }


    private fun showTypingIndicator() {
        chatMessages.add(
            ChatMessage(
                id = System.currentTimeMillis().toString(), // Generate a unique ID
                content = "...",
                isUser = false,
                isTyping = true
            )
        )
        chatAdapter.notifyItemInserted(chatMessages.size - 1)
        binding.recyclerView.smoothScrollToPosition(chatMessages.size - 1)
    }

    private fun removeTypingIndicator() {
        if (chatMessages.isNotEmpty() && chatMessages.last().isTyping) {
            chatMessages.removeAt(chatMessages.size - 1)
            chatAdapter.notifyItemRemoved(chatMessages.size - 1)
        }
    }

    /*private fun stopVoiceRecognition() {
        speechRecognizer?.stopListening()
        showRecordingStatus(false)
        binding.voiceInputButton.text = "üé§"
    }*/

    private fun shareLastResponse() {
        if (chatMessages.isNotEmpty()) {
            val lastMessage = chatMessages.lastOrNull { !it.isUser }?.content

            if (lastMessage != null && lastMessage.isNotBlank()) {
                val shareIntent = Intent().apply {
                    action = Intent.ACTION_SEND
                    type = "text/plain"
                    putExtra(Intent.EXTRA_TEXT, lastMessage)
                }

                if (shareIntent.resolveActivity(requireContext().packageManager) != null) {
                    startActivity(Intent.createChooser(shareIntent, "Share the response via"))
                } else {
                    showCustomToast("No app available to share the response")
                }
            } else {
                showCustomToast("No response available to share")
            }
        } else {
            showCustomToast("No response available to share")
        }
    }

}